---
layout: default
title: {{ site.name }}
---
# Webpack文档阅读
虽然webpack已经用了蛮久了，这次系统的看一下他的文档。

 - 插件：它具有丰富的插件接口，可以让外部做一些插件。这让webpack可扩展性。
 - 加载器：通过loader来对文件进行预编译，这就意味着可以对任意的静态资源进行打包。可以很容易的写自己的loader
 - 代码分割：允许将代码库分割成大块，这样就可以减少最初的加载时间
 - 开发工具：支持sourceUrl和sourceMap，他可以监视你的文件，通过一个开发中间件或者开发server来自动重新渲染
 - 表现：webpack使用了异步的IO，并且有多层的缓存等级，让webpack很快并且在增量编译的时候很快
 - 支持：支持AMD和Commonjs，能在分析你的代码的AST的时候表现的很聪明，甚至有一个分析的引擎
 - 优化：做了很多优化来减少打包的最后的大小，通过hash来关心请求被缓存
 - 多种目标：webpack的主要目标是web，也提供了bundle为了webworker和nodejs。

## 动机
页面上的code越来越多，需要被组织。文件系统提供了把你代码分成模块。

### 模块系统风格
定义依赖，输出结果又多种标准的：

 - 直接script，没有模块系统(自己管理好加载顺序，全局可能会冲突，用户自己处理依赖，大项目很难维护)
 - Commonjs(同步依赖，然而网络请求都是异步的)
 - AMD等等(编码要求比较高，看上去像是某种修补)
 - ES6的模块系统(本地浏览器实现需要时间，这种分格的js很少)

### 传输
现在每个模块一次request，或者所有的module合为一个请求都是存在的，webpack把代码分割成块状，提高第一次渲染的速度，然后按需引其他剩下的js。

### 为什么只是JS呢
就是说不只是js，其他的静态资源都是需要处理的，最明显的就是css，可能存在less变成css的过程。而且图片啥的，jade模板啥的都需要一个处理的过程。

## webpack是个啥
webpack是个文件打包器，就是把一坨相互依赖的静态资源模块，包括各种语言的写法。打包成js，css，png这种浏览器直接能使用的资源。

出现这个新的模块打包器的主要原因是代码分割以及静态资源必须模块化的无缝的连接在一起。

### 目标：

 - 分离依赖树成块状的，然后按需加载
 - 让loading时间尽可能短
 - 每个静态资源都能成为模块
 - 能够整合第三方的库作为模块
 - 能够定制模块加载器的每一个部分
 - 适合于大项目

### webpack为什么不同
#### 文件分割
webpack有在他的依赖树种有两种依赖：同步的和异步的。异步的依赖生成了一个新的代码块。在新的代码块被优化后，一个文件被发散出去。




## Code Splitting
对于大的web app项目来说，将所有的代码推入一个文件是效率不高的。尤其是一些代码块只在特定的场景才需要被引用。webpack拥有把你的代码分成块状并且按需要加载的能力。别的打包器把这个叫做layer，rollups，fragments。这个功能叫做代码分割。

这是一个可选的功能，可以在代码库中定义分离的点。webpack来负责处理依赖，输出文件以及运行时的材料。

来声明一个经常的误解：代码分割不仅仅是把普通的代码变成可共享的代码块。更值得关注的功能是代码分割可以把代码分成按需加载的代码块。这就让首次的下载尽可能小。并且可以在需要的时候按需加载。

### 定一个分隔的点
AMD和Commonjs定义了不同的方法来按需加载代码，都是支持的。

Commonjs：require.ensure

```javascript
    require.ensure(['moduleA','moduleB'],function(require){
        var a = require('moduleA');
    })
```

AMD的话就是本身的require就是支持的。

ES6的模块的话，webpack1.x.x是没有原生支持的，2.0.0支持。所以只能通过babel将ES6的模块转化成Commonjs或者AMD的模块。
