<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>React源码阅读</h1>

<p>用了React也有一段时间了，文档什么的也算挺熟悉了，但是内部还是一个黑盒，于是想花点时间尝试看一看里面的世界。</p>

<p>React的代码很庞大，刚打开时简直崩了，仔细看了看发现只需要看一个src文件夹就好了。</p>

<p>一句句的看肯定可能性不大，先把自己在意的几处的代码研究一下。</p>

<h2>codebase-overview</h2>

<p>react用的内部模块系统&#39;Haste&#39;，与commonjs很像，但是他比较喜欢用独一无二的名字来进行引用。不像Commonjs总是用相对路径来引入。目前的代码还是Haste风格的，后面可能会在一段时间后改成Commonjs的规范。</p>

<p>为了避免出现一些相互的引用，每个文件只能引用自己文件夹内部的。如果两个文件夹内部有公共的地方的话，我们就新建一个shared目录来保存。</p>

<p>代码里面会有一些warning和Invariants来报错。</p>

<p>现在代码里面引入了Flow来进行类型的限制了。</p>

<h3>动态注入</h3>

<p>React用了一些动态注入，主要原因是React原来是只支持DOM的。后来Reactive Native开始作为React的一个fork了。所以需要添加一些动态注入来让Reactive Native重写一些行为。(inject)未来准备抛弃动态注入，在构建时连接所有的静态。</p>

<p>与render的相关在renderers里面。</p>

<h3>Reconcilers</h3>

<p>不同的renderer例如React Dom以及React Native需要分享许多的逻辑，所以Reconcilers来管理render，用户组件，状态，生命周期方法等等跨平台的。</p>

<p>stack reconciler他管理了所有的React组件的内部实例的独立的树结构。</p>

<h2>React的component是如何创建并渲染的</h2>

<p>首先React本身返回了一个React对象。这个对象拥有着createElement方法。</p>

<h2>React的事件系统听说用了享元模式？</h2>

<p>先看下官网推荐的video讲解：</p>

<ul>
<li>EventConstents：列举了所有的监听的事件</li>
<li>SimpleEventPlugin：就是用来监听浏览器的事件触发，然后执行在组件内部申明的事件。就是都是通过plugin来处理事件的；他的事件系统目前都是支持冒泡和捕获的，但是后期可能会删去捕获，因为复杂性，而且也很少人使用。这里的每个事件在最后都会作为dependences绑上一个toplevel事件。</li>
<li>ReactBrowserEventEmitter：这个文件就是执行了一个listenTo的方法，其实就是监听在window上的。里面会查看刚才定义的dependences。然后去定义一些真正被监听的东西。然后就会交给EventListener来注册事件。然后就会执行dispatchEvent(就是你的浏览器事件被触发的时候真正被执行的第一个方法)。然后就会执行到里面的handleTopLevelImpl(会去得到那个event.target，然后拿到他真实的内部的React实例)。然后就会执行另一个函数_handleTopLevel(这个值一般是动态注入的，但是一般都是ReactEventEmitterMixin里面的handleTopLevel)，然后就会得到EventPluginHub的extrqctEvents(基本上就会执行到SimpleEventPlugin的extractEvents，执行runEventQueueInBatch。</li>
<li>SimpleEventPlugin的extractEvents：这里面就是生成最后的event事件，然后通过一个getPool来得到(这里就是传说中的享元模式了，慢慢研究一下)

<ul>
<li>SyntheticMouseEvent：我们map native event to SyntheticEvent。一般的属性都是直接拷贝的，有些特殊的属性需要兼容各种浏览器。</li>
</ul></li>
<li>EventPropagators.accumulateTwoPhaseDispatches：就是处理了capture和bubble两种事件，这里连有个数组的调用。最后执行的是EventPluginUtils.traverseTwoPhase(真正开始执行上下的冒泡的地方)。</li>
<li>然后执行到accumulateDirectionalDispatches，里面会查看这个react code有没有注册listener。</li>
<li>执行到了executeDispatchesAndRelease(就是按顺序执行，如果不需要持久化的话，就直接release)

<ul>
<li>executeDispatchesInOrder：就是真正执行用户定义的事件的地方，会检查用户时候阻止</li>
<li>ReactErrorUtils.invokeGuardedCallback：如果有error发生的时候，开发模式react会创建一个eventListener来让浏览器触发他的报错事件，就不会导致整体的挂掉了，非开发模式就会报错</li>
</ul></li>
</ul>

<h2>React的事件是什么时候绑上去的？</h2>

<p>React的component其实就是一堆属性。</p>

<p>真正的入口是ReactDOM.render开始执行</p>

<p>然后实际上执行的是ReactMount.render(如果之前render过，就会执行更新)</p>

<p>然后执行ReactMount._renderSubtreeIntoContainer</p>

<ul>
<li>参数校验以及报err和warning</li>
<li>拿parentComponent(第一次肯定是null)</li>
<li>拿prevComponent，第一次为null

<ul>
<li>判断是否需要update，需要的话执行_updateRootComponent，然后return；不需要的话执行unmountComponentAtNode?第一次肯定是false</li>
<li>执行unmountComponentAtNode，卸载container里面的render的组件。</li>
</ul></li>
<li>然后直接执行_renderNewRootComponent

<ul>
<li>执行了ensureScrollValueMonitoring？</li>
</ul>

<h2>- 将element交给instantiateReactComponent(提供一个ReactNode，创建一个真实被mount的实例)</h2></li>
</ul>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-52">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
