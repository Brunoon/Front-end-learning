<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
  <link rel="import" href="/Front-end-learning/webcomponent/github-card.html">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>Web Workers</h1>

<p>Web Workers可以让JS运行到后台，来解决JS线程可能会冻结页面的问题。我们可以将大量数据的处理交给worker来做，只将页面的渲染事情交给JS就好了。</p>

<p>基本现在有三种worker：Worker(Dedicated Worker)，SharedWorker和Service Worker。</p>

<p>浏览器支持情况：</p>

<ul>
<li>Worker：IE10+,Chrome,Safari5+等都是支持的，安卓4.4以上才支持。</li>
<li>SharedWorker：IE不支持，安卓不支持。</li>
<li>ServiceWorker：Chrome42以上才支持(实验中的)</li>
</ul>

<h2>使用Worker</h2>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">myWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;need.js&#39;</span><span class="p">);</span>
<span class="nx">myWorker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span><span class="c1">//这句话说是用来启动worker的，说是worker不接受到信息是不会触发的，但是Chrome好像只要new了就会执行..</span>
</code></pre></div>
<p>传的数据都支持字符串，自Safari4之后都支持JSON格式。所以JSON也都是可以使用的。注意，这些数据的传输都是拷贝赋值的，而不是共享的执行环境。</p>

<p>相互之间都是通过postMessage和onmessage来通信的。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//主线程</span>
<span class="kd">var</span> <span class="nx">myWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;worker.js&#39;</span><span class="p">);</span>
<span class="nx">myWorker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oEvent</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">myWorker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s2">&quot;从主线程来的&quot;</span><span class="p">);</span>
<span class="c1">//worker.js内部</span>
<span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oEvent</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;worker的数据1&#39;</span><span class="p">);</span>
<span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;worker的数据2&#39;</span><span class="p">);</span>
<span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;worker的数据3&#39;</span><span class="p">);</span>
</code></pre></div>
<p>注意我们最好在主页面中监听下error事件，因为不监听的话，worker就会默默地失败了。</p>

<p>想要停止Worker的工作，只要在主页面简单的myWorker.termiate()就行了，执行流也没有问题。</p>

<p>worker自己也可以自杀，调用self.close()就可以了。但是在worker内部的正常顺序流调用好像有些问题(感觉这句话会被套上了默认的setTimeout)，最好在onmessage里面再调用close，比较靠谱。</p>

<h2>Worker全局作用域</h2>

<p>Worker与主页面所执行的JS完全在不一样的作用域内，并不共用作用域。注意：Web Worker代码不能访问DOM，也无法任何方式影响页面的外观。特点如下：</p>

<ul>
<li>全局对象就是worker对象本身，就是说self和this都指向worker对象。</li>
<li>最小化的navigator对象，有online，appName，appVersion，userAgent和platFrom属性</li>
<li>只读的location</li>
<li>settimeout，setInterval，cleartimeout，clearinterval</li>
<li>XMLHttpRequest构造函数</li>
</ul>

<p>所以，worker的运行环境与页面相比，功能是相当有限的。</p>

<h2>worker引入其他的js</h2>

<p>我们可以用下面的语句来引入其他的js(必须是同源策略)，importScript(&#39;file1.js&#39;,&#39;file2.js&#39;);</p>

<p>这样子会按照file1，file2的顺序执行，并且会在两个都执行完了才会往下执行。而且系统默认处理好了回调的问题，同步方式写代码就可以了。</p>

<p>就是说importScripts是<code>阻塞型</code>的</p>

<h2>专用worker和共享worker</h2>

<p>共享的资源是能够在各个页面之间共享的，但是还是得同源的。规范也没有定好呢..</p>

<p>而且worker能够访问的资源太少了，基本只能主页面传递，local的，session之类的，页面信息都不能访问的到。</p>

<h2>共享worker</h2>

<p>这个东西的支持程度很差，他与worker的不同之处在于他能够被同源的多个tab页面所访问到。如果所有的tab页被关闭，那这个worker才会被关闭。使用例子：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//main</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="nb">window</span><span class="p">.</span><span class="nx">SharedWorker</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SharedWorker</span><span class="p">(</span><span class="s2">&quot;worker.js&quot;</span><span class="p">);</span>
  <span class="nx">myWorker</span><span class="p">.</span><span class="nx">port</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//worker.js</span>
<span class="kd">var</span> <span class="nx">s</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="nx">onconnect</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span><span class="o">++</span><span class="p">;</span>
  <span class="kd">var</span>  <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="nx">port</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">port</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">port</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//打开多个页面的时候s的值会被递增，也就是说，新建worker，就会触发connect。worker.js的内部变量是可以被各个tab访问到的。</span>
</code></pre></div>
<p><a href="https://github.com/mdn/simple-shared-worker">mdn给的官方例子</a>完全没能体现Sharedworker的共享的特性，差评。</p>

<h2>service worker</h2>

<p>这是个实验中的属性，chrome42以上才能够使用。基本就是测试中..</p>

<p>service worker可以监听fetch事件(拦截所有的网络请求)，开发者可以来做网络代理来做网络拦截，提供了离线的能力(没有页面也能执行)。</p>

<p>sw被更新的时候，会重新下载新的，然后install，然后等到页面上没有使用sw了，就会把老的卸掉，使用新的sw。</p>

<p>他还能够做后台推送的事情(我的理解为因为这个SW会至少24小时重新下载一次，然后在里面写上脚本，执行上面的更新操作后，触发推送)。</p>

<p>注意sw只能运行在https中，localhost也可以。</p>

<p>参考：</p>

<p>http://www.html5rocks.com/zh/tutorials/workers/basics/</p>

<p>http://imweb.io/topic/559d13ec3d7bb8096b69cfcf</p>

<p>http://www.alloyteam.com/2016/01/9274/</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
