<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>Front-end-learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">Front-end-learning</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>


    <section class="main-content">
      
      <h1 id="promisepromise">Promise规范以及写一个Promise</h1>
<p>看了些promise的介绍，但是还是感觉不够深入，这个在解决异步问题上是一个很好的解决方案，所以详细看一下。</p>

<h2 id="promisea">Promise/A+规范：</h2>
<ul>
  <li>重新阅读了下A+的<a href="https://promisesaplus.com/">规范</a>:
    <ul>
      <li>promise代表了一个异步操作的最终结果，主要是通过then方法来注册成功以及失败的情况，</li>
      <li>Promise/A+历史上说是实现了Promise/A的行为并且考虑了一些不足之处，他并不关心如何创建，完成，拒绝Promise，只考虑提供一个可协作的then方法。</li>
    </ul>
  </li>
</ul>

<h3 id="section">术语：</h3>
<ul>
  <li><code class="highlighter-rouge">promise</code>是一个拥有符合上面的特征的then方法的对象或者方法。</li>
  <li><code class="highlighter-rouge">thenable</code>是定义了then方法的对象或者方法</li>
  <li><code class="highlighter-rouge">value</code>是任何合法的js的值（包括undefined，thenable或者promise）</li>
  <li><code class="highlighter-rouge">exception</code>是一个被throw申明抛出的值</li>
  <li><code class="highlighter-rouge">reason</code>是一个指明了为什么promise被拒绝</li>
</ul>

<h3 id="section-1">2.1 状态要求：</h3>
<ul>
  <li>promise必须是在pending，fulfilled或者rejected之间的一种状态。</li>
  <li>promise一旦从pending变成了fulfilled或则rejected，就不能再改变了。</li>
  <li>promise变成fulfilled之后，必须有一个value，并且不能被改变</li>
  <li>promise变成rejected之后，必须有一个reason，并且不能被改变</li>
</ul>

<h3 id="then">2.2 then方法的要求：</h3>
<ul>
  <li>promise必须有个then方法来接触当前的或者最后的value或者reason</li>
  <li>then方法接受两个参数，done和onRejected，这两个都是可选的，如果传入的不是function的话，就会被忽略</li>
  <li>如果done是一个函数，他必须在promise完成后被执行(不能提前)，并且value是第一个参数，并且不能被执行超过一次</li>
  <li>如果onRejected是一个函数，他必须在promise拒绝后被执行(不能提前)，并且reason是第一个参数，并且不能被执行超过一次</li>
  <li>done或者onRejected只能在执行上下文堆只包含了平台代码的时候执行(就是要求done和onrejected必须异步执行，必须在then方法被调用的那一轮事件循环之后的新执行栈执行，这里可以使用macro-task或者micro-task，这两个的区别参见<a href="https://github.com/panyifei/learning/blob/master/前端基础/Macro-task与Micro-task.md">文章</a>)</li>
  <li>done或者onRejected必须作为function被执行(就是说没有一个特殊的this，在严格模式中，this就是undefined，在粗糙的模式，就是global)</li>
  <li>then方法可能在同一个promise被调用多次，当promise被完成，所有的done必须被顺序执行，onRejected也一样</li>
  <li>then方法必须也返回一个promise(这个promise可以是原来的promise，实现必须申明什么情况下两者可以相等)promise2 = promise1.then(done, onRejected);
    - 如果<code class="highlighter-rouge">done</code>和<code class="highlighter-rouge">onRejected</code>都返回一个value x，执行2.3Promise的解决步骤<a href="promise2, x">[Resolve]</a>
    - 如果<code class="highlighter-rouge">done</code>和<code class="highlighter-rouge">onRejected</code>都抛出exception e，promise2必须被rejected同样的e
    - 如果<code class="highlighter-rouge">done</code>不是个function，且promise1 is fulfilled，promise2也会fulfilled，和promise1的值一样
    - 如果<code class="highlighter-rouge">onRejected</code>不是个function，且promise1 is rejected，promise2也会rejected，理由和promise1一样</li>
</ul>

<p>这里不论promise1被完成还是被拒绝，promise2 都会被 resolve的，只有出现了一些异常才会被rejected</p>

<h3 id="promiseresolvepromise2-x">2.3Promise的解决步骤==<a href="promise2, x">[Resolve]</a></h3>
<ul>
  <li>这个是将<code class="highlighter-rouge">promise</code>和一个值<code class="highlighter-rouge">x</code>作为输入的一个抽象操作。如果这个x是支持then的，他会尝试让promise接受x的状态；否则，他会用x的值来fullfill这个promise。运行这样一个东西，遵循以下的步骤</li>
  <li>如果promise和x指向同一个对象，则reject这个promise使用TypeError。</li>
  <li>如果x是一个promise，接受他的状态</li>
  <li>如果x在pending，promise必须等待x的状态改变</li>
  <li>如果x被fullfill，那么fullfill这个promise使用同一个value</li>
  <li>如果x被reject，那么reject这个promise使用同一个理由</li>
  <li>如果x是一个对象或者是个方法</li>
  <li>如果x.then返回了错误，则reject这个promise使用错误。</li>
  <li>如果then是一个方法，使用x为this，resolvePromise为一参，rejectPromise为二参，
    - 如果resolvePromise被一个值y调用，那么运行<a href="promise, y">[Resolve]</a>
    - 如果rejectPromise被reason r，使用r来reject这个promise
    - 如果resolvePromise和rejectPromise都被调用了，那么第一个被调用的有优先权，其他的beihulue
    - 如果调用then方法得到了exception，如果上面的方法被调用了，则忽略，否则reject这个promise</li>
  <li>如果then方法不是function，那么fullfill这个promise使用x</li>
  <li>如果x不是一个对象或者方法，那么fullfill这个promise使用x</li>
</ul>

<p>如果promise产生了环形的嵌套，比如<a href="promise, thenable">[Resolve]</a>最终唤起了<a href="promise, thenable">[Resolve]</a>，那么实现建议且并不强求来发现这种循环，并且reject这个promise使用一个TypeError。</p>

<h2 id="promise">写一个promise</h2>
<p>想要写一个Promise，肯定得使用一个异步的函数，就拿setTimeout来做。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'success'</span><span class="p">)},</span><span class="kd">function</span><span class="p">(){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'fail'</span><span class="p">)});</span>
</code></pre>
</div>

<h3 id="section-2">初步构建</h3>
<p>上面是个最简单的使用场景我们需要慢慢来构建</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要一个成功时的回调</span>
  <span class="kd">var</span> <span class="nx">doneCallback</span><span class="p">;</span>
  <span class="c1">//一个实例的方法，用来注册异步事件</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
    <span class="nx">doneCallback</span> <span class="o">=</span> <span class="nx">done</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
    <span class="nx">doneCallback</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="section-3">加入链式支持</h3>
<p>下面加入链式，成功回调的方法就得变成数组才能存储</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要成功以及成功时的回调</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">//一个实例的方法，用来注册异步事件</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span> <span class="p">,</span><span class="nx">fail</span><span class="p">){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
      <span class="nx">fulfill</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这里promise里面如果是同步的函数的话，doneList里面还是空的，所以可以加个setTimeout来将这个放到js的最后执行。这里主要是参照了promiseA+的规范，就像这样</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
      <span class="nx">fulfill</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="section-4">加入状态机制</h3>
<p>这时如果promise已经执行完了，我们再给promise注册then方法就怎么都不会执行了，这个不符合预期，所以才会加入状态这种东西。更新过的代码如下</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要成功以及成功时的回调</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">'pending'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">//一个实例的方法，用来注册异步事件</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>
      <span class="k">case</span> <span class="s2">"pending"</span><span class="err">:</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">'fulfilled'</span><span class="err">:</span>
        <span class="nx">done</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">"fulfilled"</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
        <span class="nx">fulfill</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="section-5">加上异步结果的传递</h3>
<p>现在的写法根本没有考虑异步返回的结果的传递，我们来加上结果的传递</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="s2">"fulfilled"</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
      <span class="nx">value</span> <span class="o">=</span> <span class="nx">fulfill</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="section-6">支持串行</h3>
<p>这样子我们就可以将then每次的结果交给后面的then了。但是我们的promise现在还不支持promise的串行写法。比如我们想要</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
      <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span><span class="k">return</span> <span class="mi">33</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">)})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">home</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">home</span><span class="p">)});</span>
</code></pre>
</div>

<p>所以我们必须改下then方法。</p>

<p>当then方法传入一般的函数的时候，我们目前的做法是将它推进了一个数组，然后return this来进行链式的调用，并且期望在resolve方法调用时执行这个数组。</p>

<p>最开始我是研究的美团工程师的<a href="http://tech.meituan.com/promise-insight.html">一篇博客</a>,到这里的时候发现他的解决方案比较跳跃，于是我就按照普通的正常思路先尝试了下：</p>

<p>如果传入一个promise的话，我们先尝试继续推入数组中，在resolve的地方进行区分，发现是可行的，我先贴下示例代码，然后会有详细的注释。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要成功以及成功时的回调</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">'pending'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>
      <span class="k">case</span> <span class="s2">"pending"</span><span class="err">:</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">'fulfilled'</span><span class="err">:</span>
        <span class="nx">done</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">"fulfilled"</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
      <span class="c1">//执行resolve时，我们会尝试将doneList数组中的值都执行一遍</span>
      <span class="c1">//当遇到正常的回调函数的时候，就执行回调函数</span>
      <span class="c1">//当遇到一个新的promise的时候，就将原doneList数组里的回调函数推入新的promise的doneList，以达到循环的目的</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">value</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">temp</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">newP</span> <span class="o">=</span>  <span class="nx">temp</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nx">newP</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">value</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="s1">'p 的结果'</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p2拿到前面传入的值：'</span> <span class="o">+</span> <span class="nx">input</span><span class="p">)</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s1">'p2的结果'</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">p</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p的结果:'</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">'p then方法第一次返回'</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p第一次then方法的返回：'</span><span class="o">+</span><span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">'p then方法第二次返回'</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p2的结果：'</span> <span class="o">+</span> <span class="nx">res</span><span class="p">)});</span>
</code></pre>
</div>

<h3 id="reject">加入reject</h3>
<p>我按照正常思路这么写的时候发现出了点问题，因为按照最上面的规范。即使一个promise被rejected，他注册的then方法之后再注册的then方法会可能继续执行resolve的。即我们在then方法中为了链式返回的this的status是可能会被改变的，假设我们在实现中来改变状态而不暴露出来(这其实一点并不推荐)。</p>

<p>我直接贴实现的代码，还有注释作为讲解</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">'pending'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">failList</span><span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span> <span class="p">,</span><span class="nx">fail</span><span class="p">){</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>
      <span class="k">case</span> <span class="s2">"pending"</span><span class="err">:</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
        <span class="c1">//每次如果没有推入fail方法，我也会推入一个null来占位</span>
        <span class="nx">failList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fail</span> <span class="o">||</span> <span class="kc">null</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">'fulfilled'</span><span class="err">:</span>
        <span class="nx">done</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">'rejected'</span><span class="err">:</span>
        <span class="nx">fail</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">"fulfilled"</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">temp</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">newP</span> <span class="o">=</span>  <span class="nx">temp</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nx">newP</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">failList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">value</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">"rejected"</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">tempRe</span> <span class="o">=</span> <span class="nx">failList</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="nx">value</span><span class="p">);</span>
      <span class="c1">//如果reject里面传入了一个promise，那么执行完此次的fail之后，将剩余的done和fail传入新的promise中</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">tempRe</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">newP</span> <span class="o">=</span> <span class="nx">tempRe</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nx">newP</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">failList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="c1">//如果不是promise，执行完当前的fail之后，继续执行doneList</span>
        <span class="nx">value</span> <span class="o">=</span>  <span class="nx">tempRe</span><span class="p">;</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="nx">failList</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">reject</span><span class="p">(</span><span class="s1">'p 的结果'</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p2拿到前面传入的值：'</span> <span class="o">+</span> <span class="nx">input</span><span class="p">)</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s1">'p2的结果'</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">p</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p的结果:'</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">'p then方法第一次返回'</span><span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="k">return</span> <span class="s1">'p then方法第一次错误的返回'</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p第一次then方法的返回：'</span><span class="o">+</span><span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">'p then方法第二次返回'</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p2的结果：'</span> <span class="o">+</span> <span class="nx">res</span><span class="p">)});</span>
</code></pre>
</div>
<p>用图片展示一下思路的话可能会更清晰些：</p>

<p>then方法的初始化过程很简单：</p>

<p><img alt="" width="500px" src="pics//my-then.png" /></p>

<p>执行时的过程是这样的：</p>

<p><img alt="" width="700px" src="pics//my-resolve.png" /></p>

<p>正常思路的解决方案基本就是这样了</p>

<h3 id="section-7">另外的套路</h3>
<p>看的一篇美团工程师的博文，解决思路是每次then方法返回的都是一个新的promise，这样其实对于规范来说是最准确的，因为这样子我们就不需要改变promise的状态了。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">'pending'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">doneLists</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
            <span class="nx">handle</span><span class="p">({</span>
                <span class="na">done</span><span class="p">:</span> <span class="nx">done</span> <span class="o">||</span> <span class="kc">null</span><span class="p">,</span>
                <span class="na">resolve</span><span class="p">:</span> <span class="nx">resolve</span>
            <span class="p">});</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">newValue</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">newValue</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">newValue</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">then</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">newValue</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">state</span> <span class="o">=</span> <span class="s1">'fulfilled'</span><span class="p">;</span>
        <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">doneLists</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">'pending'</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">doneLists</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">deferred</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="nx">deferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="s1">'p 的结果'</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">p</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p的结果:'</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">'p then方法第一次返回'</span><span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="k">return</span> <span class="s1">'p then方法第一次错误的返回'</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'p第一次then方法的返回：'</span><span class="o">+</span><span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">'p then方法第二次返回'</span><span class="p">})</span>
</code></pre>
</div>

<p>这个思路就是说：</p>

<ul>
  <li>调用Promise a的then方法会创建一个Promise b,然后将参数done和b的resolve方法作为对象推入a的doneLists数组中；</li>
  <li>然后处理顺序就是遍历a的doneLists时，执行done，然后调用b的resolve；</li>
  <li>这样then如果传入的是一个执行之后是promise的方法，就在上一层resolve时再用.then方法包装一环；</li>
</ul>

<p>then方法的运行图像就像是这样的：</p>

<p><img alt="" width="600px" src="pics//m-then.png" /></p>

<p>执行过程就像是下面这样：</p>

<p><img alt="" width="800px" src="pics//m-resolve.png" /></p>

<h3 id="section-8">其他的思路</h3>
<p>tudo:待定</p>

<p>参考：</p>

<ul>
  <li><a href="https://promisesaplus.com/">PromiseA+的规范</a></li>
  <li>http://tech.meituan.com/promise-insight.html</li>
</ul>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">Front-end-learning</a> is maintained by <a href="http://yourhomepage.com">panyifei</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span>
</footer>


    </section>

  </body>
</html>
