<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
  <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <h1>Promise规范以及写一个Promise</h1>

<p>看了些promise的介绍，但是还是感觉不够深入，这个在解决异步问题上是一个很好的解决方案，所以详细看一下。</p>

<h2>Promise/A+规范：</h2>

<ul>
<li>重新阅读了下A+的<a href="https://promisesaplus.com/">规范</a>:

<ul>
<li>promise代表了一个异步操作的最终结果，主要是通过then方法来注册成功以及失败的情况，</li>
<li>Promise/A+历史上说是实现了Promise/A的行为并且考虑了一些不足之处，他并不关心如何创建，完成，拒绝Promise，只考虑提供一个可协作的then方法。</li>
</ul></li>
</ul>

<h3>术语：</h3>

<ul>
<li><code>promise</code>是一个拥有符合上面的特征的then方法的对象或者方法。</li>
<li><code>thenable</code>是定义了then方法的对象或者方法</li>
<li><code>value</code>是任何合法的js的值（包括undefined，thenable或者promise）</li>
<li><code>exception</code>是一个被throw申明抛出的值</li>
<li><code>reason</code>是一个指明了为什么promise被拒绝</li>
</ul>

<h3>2.1 状态要求：</h3>

<ul>
<li>promise必须是在pending，fulfilled或者rejected之间的一种状态。</li>
<li>promise一旦从pending变成了fulfilled或则rejected，就不能再改变了。</li>
<li>promise变成fulfilled之后，必须有一个value，并且不能被改变</li>
<li>promise变成rejected之后，必须有一个reason，并且不能被改变</li>
</ul>

<h3>2.2 then方法的要求：</h3>

<ul>
<li>promise必须有个then方法来接触当前的或者最后的value或者reason</li>
<li>then方法接受两个参数，done和onRejected，这两个都是可选的，如果传入的不是function的话，就会被忽略</li>
<li>如果done是一个函数，他必须在promise完成后被执行(不能提前)，并且value是第一个参数，并且不能被执行超过一次</li>
<li>如果onRejected是一个函数，他必须在promise拒绝后被执行(不能提前)，并且reason是第一个参数，并且不能被执行超过一次</li>
<li>done或者onRejected只能在执行上下文堆只包含了平台代码的时候执行(就是要求done和onrejected必须异步执行，必须在then方法被调用的那一轮事件循环之后的新执行栈执行，这里可以使用macro-task或者micro-task，这两个的区别参见<a href="https://github.com/panyifei/learning/blob/master/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Macro-task%E4%B8%8EMicro-task.md">文章</a>)</li>
<li>done或者onRejected必须作为function被执行(就是说没有一个特殊的this，在严格模式中，this就是undefined，在粗糙的模式，就是global)</li>
<li>then方法可能在同一个promise被调用多次，当promise被完成，所有的done必须被顺序执行，onRejected也一样</li>
<li>then方法必须也返回一个promise(这个promise可以是原来的promise，实现必须申明什么情况下两者可以相等)promise2 = promise1.then(done, onRejected);

<ul>
<li>如果<code>done</code>和<code>onRejected</code>都返回一个value x，执行2.3Promise的解决步骤<a href="promise2,%20x">[Resolve]</a></li>
<li>如果<code>done</code>和<code>onRejected</code>都抛出exception e，promise2必须被rejected同样的e</li>
<li>如果<code>done</code>不是个function，且promise1 is fulfilled，promise2也会fulfilled，和promise1的值一样</li>
<li>如果<code>onRejected</code>不是个function，且promise1 is rejected，promise2也会rejected，理由和promise1一样</li>
</ul></li>
</ul>

<p>这里不论promise1被完成还是被拒绝，promise2 都会被 resolve的，只有出现了一些异常才会被rejected</p>

<h3>2.3Promise的解决步骤==<a href="promise2,%20x">[Resolve]</a></h3>

<ul>
<li>这个是将<code>promise</code>和一个值<code>x</code>作为输入的一个抽象操作。如果这个x是支持then的，他会尝试让promise接受x的状态；否则，他会用x的值来fullfill这个promise。运行这样一个东西，遵循以下的步骤

<ul>
<li>如果promise和x指向同一个对象，则reject这个promise使用TypeError。</li>
<li>如果x是一个promise，接受他的状态</li>
<li>如果x在pending，promise必须等待x的状态改变</li>
<li>如果x被fullfill，那么fullfill这个promise使用同一个value</li>
<li>如果x被reject，那么reject这个promise使用同一个理由</li>
<li>如果x是一个对象或者是个方法</li>
<li>如果x.then返回了错误，则reject这个promise使用错误。</li>
<li>如果then是一个方法，使用x为this，resolvePromise为一参，rejectPromise为二参，</li>
<li>如果resolvePromise被一个值y调用，那么运行<a href="promise,%20y">[Resolve]</a></li>
<li>如果rejectPromise被reason r，使用r来reject这个promise</li>
<li>如果resolvePromise和rejectPromise都被调用了，那么第一个被调用的有优先权，其他的beihulue</li>
<li>如果调用then方法得到了exception，如果上面的方法被调用了，则忽略，否则reject这个promise</li>
<li>如果then方法不是function，那么fullfill这个promise使用x</li>
<li>如果x不是一个对象或者方法，那么fullfill这个promise使用x</li>
</ul></li>
</ul>

<p>如果promise产生了环形的嵌套，比如<a href="promise,%20thenable">[Resolve]</a>最终唤起了<a href="promise,%20thenable">[Resolve]</a>，那么实现建议且并不强求来发现这种循环，并且reject这个promise使用一个TypeError。</p>

<h2>写一个promise</h2>

<p>想要写一个Promise，肯定得使用一个异步的函数，就拿setTimeout来做。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;success&#39;</span><span class="p">)},</span><span class="kd">function</span><span class="p">(){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">)});</span>
</code></pre></div>
<h3>初步构建</h3>

<p>上面是个最简单的使用场景我们需要慢慢来构建</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要一个成功时的回调</span>
  <span class="kd">var</span> <span class="nx">doneCallback</span><span class="p">;</span>
  <span class="c1">//一个实例的方法，用来注册异步事件</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
    <span class="nx">doneCallback</span> <span class="o">=</span> <span class="nx">done</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
    <span class="nx">doneCallback</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3>加入链式支持</h3>

<p>下面加入链式，成功回调的方法就得变成数组才能存储</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要成功以及成功时的回调</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">//一个实例的方法，用来注册异步事件</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span> <span class="p">,</span><span class="nx">fail</span><span class="p">){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
      <span class="nx">fulfill</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这里promise里面如果是同步的函数的话，doneList里面还是空的，所以可以加个setTimeout来将这个放到js的最后执行。这里主要是参照了promiseA+的规范，就像这样</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
      <span class="nx">fulfill</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3>加入状态机制</h3>

<p>这时如果promise已经执行完了，我们再给promise注册then方法就怎么都不会执行了，这个不符合预期，所以才会加入状态这种东西。更新过的代码如下</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要成功以及成功时的回调</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">//一个实例的方法，用来注册异步事件</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>
      <span class="k">case</span> <span class="s2">&quot;pending&quot;</span><span class="o">:</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">&#39;fulfilled&#39;</span><span class="o">:</span>
        <span class="nx">done</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">&quot;fulfilled&quot;</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
        <span class="nx">fulfill</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3>加上异步结果的传递</h3>

<p>现在的写法根本没有考虑异步返回的结果的传递，我们来加上结果的传递</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="s2">&quot;fulfilled&quot;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">doneList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">fulfill</span><span class="p">){</span>
      <span class="nx">value</span> <span class="o">=</span> <span class="nx">fulfill</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3>支持串行</h3>

<p>这样子我们就可以将then每次的结果交给后面的then了。但是我们的promise现在还不支持promise的串行写法。比如我们想要</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
      <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span><span class="k">return</span> <span class="mi">33</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">)})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">home</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">home</span><span class="p">)});</span>
</code></pre></div>
<p>所以我们必须改下then方法。</p>

<p>当then方法传入一般的函数的时候，我们目前的做法是将它推进了一个数组，然后return this来进行链式的调用，并且期望在resolve方法调用时执行这个数组。</p>

<p>最开始我是研究的美团工程师的<a href="http://tech.meituan.com/promise-insight.html">一篇博客</a>,到这里的时候发现他的解决方案比较跳跃，于是我就按照普通的正常思路先尝试了下：</p>

<p>如果传入一个promise的话，我们先尝试继续推入数组中，在resolve的地方进行区分，发现是可行的，我先贴下示例代码，然后会有详细的注释。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="c1">//需要成功以及成功时的回调</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>
      <span class="k">case</span> <span class="s2">&quot;pending&quot;</span><span class="o">:</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">&#39;fulfilled&#39;</span><span class="o">:</span>
        <span class="nx">done</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">&quot;fulfilled&quot;</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
      <span class="c1">//执行resolve时，我们会尝试将doneList数组中的值都执行一遍</span>
      <span class="c1">//当遇到正常的回调函数的时候，就执行回调函数</span>
      <span class="c1">//当遇到一个新的promise的时候，就将原doneList数组里的回调函数推入新的promise的doneList，以达到循环的目的</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">value</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">temp</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">newP</span> <span class="o">=</span>  <span class="nx">temp</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nx">newP</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">value</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;p 的结果&#39;</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p2拿到前面传入的值：&#39;</span> <span class="o">+</span> <span class="nx">input</span><span class="p">)</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;p2的结果&#39;</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">p</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p的结果:&#39;</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">&#39;p then方法第一次返回&#39;</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p第一次then方法的返回：&#39;</span><span class="o">+</span><span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">&#39;p then方法第二次返回&#39;</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p2的结果：&#39;</span> <span class="o">+</span> <span class="nx">res</span><span class="p">)});</span>
</code></pre></div>
<h3>加入reject</h3>

<p>我按照正常思路这么写的时候发现出了点问题，因为按照最上面的规范。即使一个promise被rejected，他注册的then方法之后再注册的then方法会可能继续执行resolve的。即我们在then方法中为了链式返回的this的status是可能会被改变的，假设我们在实现中来改变状态而不暴露出来(这其实一点并不推荐)。</p>

<p>我直接贴实现的代码，还有注释作为讲解</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">doneList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">failList</span><span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span> <span class="p">,</span><span class="nx">fail</span><span class="p">){</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>
      <span class="k">case</span> <span class="s2">&quot;pending&quot;</span><span class="o">:</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
        <span class="c1">//每次如果没有推入fail方法，我也会推入一个null来占位</span>
        <span class="nx">failList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fail</span> <span class="o">||</span> <span class="kc">null</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">&#39;fulfilled&#39;</span><span class="o">:</span>
        <span class="nx">done</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="s1">&#39;rejected&#39;</span><span class="o">:</span>
        <span class="nx">fail</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">&quot;fulfilled&quot;</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">temp</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">newP</span> <span class="o">=</span>  <span class="nx">temp</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nx">newP</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">failList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">value</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="s2">&quot;rejected&quot;</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">tempRe</span> <span class="o">=</span> <span class="nx">failList</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="nx">value</span><span class="p">);</span>
      <span class="c1">//如果reject里面传入了一个promise，那么执行完此次的fail之后，将剩余的done和fail传入新的promise中</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">tempRe</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">newP</span> <span class="o">=</span> <span class="nx">tempRe</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">doneList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nx">newP</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doneList</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">failList</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="c1">//如果不是promise，执行完当前的fail之后，继续执行doneList</span>
        <span class="nx">value</span> <span class="o">=</span>  <span class="nx">tempRe</span><span class="p">;</span>
        <span class="nx">doneList</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="nx">failList</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">},</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">reject</span><span class="p">(</span><span class="s1">&#39;p 的结果&#39;</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p2拿到前面传入的值：&#39;</span> <span class="o">+</span> <span class="nx">input</span><span class="p">)</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;p2的结果&#39;</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">p</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p的结果:&#39;</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">&#39;p then方法第一次返回&#39;</span><span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="k">return</span> <span class="s1">&#39;p then方法第一次错误的返回&#39;</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p第一次then方法的返回：&#39;</span><span class="o">+</span><span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">&#39;p then方法第二次返回&#39;</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p2的结果：&#39;</span> <span class="o">+</span> <span class="nx">res</span><span class="p">)});</span>
</code></pre></div>
<p>用图片展示一下思路的话可能会更清晰些：</p>

<p>then方法的初始化过程很简单：</p>

<p><img alt="" width='500px' src="pics//my-then.png" /></p>

<p>执行时的过程是这样的：</p>

<p><img alt="" width='700px' src="pics//my-resolve.png" /></p>

<p>正常思路的解决方案基本就是这样了</p>

<h3>另外的套路</h3>

<p>看的一篇美团工程师的博文，解决思路是每次then方法返回的都是一个新的promise，这样其实对于规范来说是最准确的，因为这样子我们就不需要改变promise的状态了。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Promise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;pending&#39;</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">doneLists</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
            <span class="nx">handle</span><span class="p">({</span>
                <span class="nx">done</span><span class="o">:</span> <span class="nx">done</span> <span class="o">||</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nx">resolve</span><span class="o">:</span> <span class="nx">resolve</span>
            <span class="p">});</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">newValue</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">newValue</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">newValue</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">then</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">newValue</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;fulfilled&#39;</span><span class="p">;</span>
        <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">doneLists</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;pending&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">doneLists</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">deferred</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">deferred</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="nx">deferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;p 的结果&#39;</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="nx">p</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p的结果:&#39;</span> <span class="o">+</span> <span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">&#39;p then方法第一次返回&#39;</span><span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="k">return</span> <span class="s1">&#39;p then方法第一次错误的返回&#39;</span><span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;p第一次then方法的返回：&#39;</span><span class="o">+</span><span class="nx">res</span><span class="p">);</span> <span class="k">return</span> <span class="s1">&#39;p then方法第二次返回&#39;</span><span class="p">})</span>
</code></pre></div>
<p>这个思路就是说：</p>

<ul>
<li>调用Promise a的then方法会创建一个Promise b,然后将参数done和b的resolve方法作为对象推入a的doneLists数组中；</li>
<li>然后处理顺序就是遍历a的doneLists时，执行done，然后调用b的resolve；</li>
<li>这样then如果传入的是一个执行之后是promise的方法，就在上一层resolve时再用.then方法包装一环；</li>
</ul>

<p>then方法的运行图像就像是这样的：</p>

<p><img alt="" width='600px' src="pics//m-then.png" /></p>

<p>执行过程就像是下面这样：</p>

<p><img alt="" width='800px' src="pics//m-resolve.png" /></p>

<h3>其他的思路</h3>

<p>tudo:待定</p>

<p>参考：</p>

<ul>
<li><a href="https://promisesaplus.com/">PromiseA+的规范</a></li>
<li>http://tech.meituan.com/promise-insight.html</li>
</ul>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
