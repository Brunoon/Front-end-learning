<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>Front-end-learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">Front-end-learning</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="#" class="btn">View on GitHub</a>
  <a href="#" class="btn">Download .zip</a>
  <a href="#" class="btn">Download .tar.gz</a>
</section>


    <section class="main-content">
      
      <h1 id="polyfill">Polyfill源码阅读</h1>
<p>在勐喆的推荐下，开始看一些比较浅层次的源码，来加深对于规范的理解。看<a href="https://github.com/inexorabletash/polyfill">polyfill</a>顺便可以看一下js的兼容，还可以了解一些不常用的API</p>

<h2 id="cssom">CSSOM</h2>
<p>### getBoundingClientRect这个方法在ie8下的修正
<code class="highlighter-rouge">javascript
if ('TextRectangle' in this &amp;&amp; !('width' in TextRectangle.prototype)) {
    Object.defineProperties(TextRectangle.prototype, {
      'width': { get: function() { return this.right - this.left; } },
      'height': { get: function() { return this.bottom - this.top; } }
    });
  }
</code></p>

<p>getBoundingClientRect这个方法得到这个元素的size并且相对于视图的定位,返回的几个值都是<code class="highlighter-rouge">只读</code>的</p>

<p>这里对getBoundingClientRect方法在ie8下面没有width和height进行了休整。就是对ie8 window下的TextRectangle进行了defineProperties。将width和height进行了定义（这里的定义之所以使用defineProperties是因为这里定义了访问器属性，这个属性不能直接定义）。注意在新的浏览器里面，TextRectangle已经改名了。</p>

<p>注意这里使用的defineProperties在ie 8以下并不支持，所以这个polyfill已经对这个方法进行了修整。就是循环调用了ie8支持的defineProperty而已，至于ie7以下不支持的defineProperty，会在下面进行分析。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">properties</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
</code></pre>
</div>

<p>这里通过hasOwnProperty这个判断来只遍历properties里面的属性，而不是原型对象上的属性；使用call来调用是为了防止对象上自己申明了这个方法，这样子可以使用原型上的。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">s</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">//true</span>
</code></pre>
</div>

<p>这里通过Object方法来判断传入的是不是一个object~这个写法有点意思。</p>

<h2 id="dom">Dom</h2>
<p>### querySelectorAll
<code class="highlighter-rouge">javascript
document.querySelectorAll = function(selectors) {
      var style = document.createElement('style'), elements = [], element;
      document.documentElement.firstChild.appendChild(style);
      document._qsa = [];
      style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa &amp;&amp; document._qsa.push(this))}';
      window.scrollBy(0, 0);
      style.parentNode.removeChild(style);
      while (document._qsa.length) {
        element = document._qsa.shift();
        element.style.removeAttribute('x-qsa');
        elements.push(element);
      }
      document._qsa = null;
      return elements;
    };
</code></p>

<p>看的好开心，感觉实现很有意思，通过支持率较好的css选择器来做这件事情</p>

<p>就是新建一个style的元素，并且使用传入的字段作为选择器，然后自定义了一个x-qsa的属性。使用到了expression这个东西来调用js，就是应用到的元素自身推入一个准备好的数组中。</p>

<p>然后遍历数组，得到最后的结果了，大赞！！</p>

<p>写法虽然不错，但是css的expression ie8以后不再支持了，比较尴尬，但是用这个来兼容ie7及以下还是很有意思的。</p>

<h3 id="queryselector">querySelector</h3>
<p>就是调用querySelectorAll，然后返回第一个值就行了</p>

<h3 id="getelementsbyclassname">getElementsByClassName</h3>
<p>类似的，调用上面的querySelectorAll，只要在前面替换个.就行了</p>

<h3 id="node-">Node 类型</h3>
<p>因为ie没有公布它的Node Type。所以这里添加了Node.ELEMENT_NODE这些。</p>

<h3 id="domexception">DOMException</h3>
<p>与上面类似的，定义了DOMException的一些种类</p>

<h3 id="event">Event</h3>
<p>重写了ie8以下的一些事件处理，包括通过attachevent来模拟addEventListener，通过detachEvent来模拟removeEventListener，这些ie9才支持</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">Window</span><span class="p">,</span> <span class="nx">HTMLDocument</span><span class="p">,</span> <span class="nx">Element</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">o</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addEventListener</span> <span class="o">=</span> <span class="nx">addEventListener</span><span class="p">;</span>
      <span class="nx">o</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">removeEventListener</span> <span class="o">=</span> <span class="nx">removeEventListener</span><span class="p">;</span>
    <span class="p">});</span>
</code></pre>
</div>

<p>重写了这几个方法之后对window和element应用。</p>

<h3 id="domtokenlist">DOMTokenList</h3>
<p>这个东西就是一个接口，一个格式，元素的classList，rellist就是遵从的这个规范，就是以空格分开的一些字符串而已。这里就是为IE9以下重写了这个东西，提供了一个构造函数，并且使用defineProperty来提供那些toggle，add等等的方法。</p>

<h2 id="es5">es5</h2>
<p>### getPrototypeOf
这个方法IE8以下不支持。</p>

<p>实现就是在判断了<code class="highlighter-rouge">obj !== Object(obj)</code>也就是返回 <code class="highlighter-rouge">obj.__proto__  || obj.constructor.prototype || Object.prototype</code>,__proto__这个属性是一些浏览器自己的实现(google,safari,ff)的，不推荐使用。</p>

<p>注意这个方法在ES6下的shim比较复杂，因为在ES6下，一个字符串会返回<code class="highlighter-rouge">String.prototype</code>，而es5则会报错，不过这个方法支持的很好。参见<a href="http://www.webbrowsercompatibility.com/es6/desktop/">ES6支持</a></p>

<h3 id="getownpropertynames">getOwnPropertyNames</h3>
<p>IE8以下不支持。</p>

<p>这个就是返回所有属于他自己的属性，包括可枚举的和不可枚举的。实现就是在for in中运行一次Object.prototype.hasOwnProperty就可以了，当然这样不可枚举的就不行了。</p>

<p>这个polyfill有一些问题，不能cover下面的，参见<a href="">mdn文档规范</a></p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">arr</span><span class="p">).</span><span class="nx">sort</span><span class="p">());</span> <span class="c1">// logs '0,1,2,length'</span>
</code></pre>
</div>

<p>因为他的写法是通过for in循环的，而length在array中是不可枚举的，作者表示除了原生的getOwnPropertyNames，其他没法拿到不可枚举的。</p>

<h3 id="objectcreate">Object.create</h3>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">properties</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">prototype</span> <span class="o">!==</span> <span class="s2">"object"</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">Ctor</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">Ctor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Ctor</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prototype</span><span class="p">)</span> <span class="p">{</span> <span class="nx">o</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Ctor</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">properties</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">properties</span> <span class="o">!==</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">properties</span><span class="p">))</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span> <span class="p">}</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">properties</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre>
</div>

<p>第一个参数是原型，第二个参数是property，才开始还以为这里比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill">mdn文档网站</a>上的polyfill写的好。因为他敢用defineProperties，结果后来才发现他也就支持了get，set和value。</p>

<p>mdn上的直接循环赋值了第二个参数，所以那些getter，setter，writable，enumerable属性没法设定了，这里鸡贼的调用了defineProperties，后面他的实现也只有getter和setter。</p>

<p>这里把constructor赋值回去的做法已经被放弃了，浏览器都已经放弃这一步操作了….</p>

<h3 id="objectdefineproperty">Object.defineProperty</h3>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="o">||</span>
      <span class="o">!</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">try</span> <span class="p">{</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">({},</span> <span class="s1">'x'</span><span class="p">,</span> <span class="p">{});</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="p">()))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">orig</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// In IE8 try built-in implementation for defining properties on DOM prototypes.</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orig</span><span class="p">)</span> <span class="p">{</span> <span class="k">try</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">orig</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">desc</span><span class="p">);</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{}</span> <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">!==</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">o</span><span class="p">))</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">"Object.defineProperty called on non-object"</span><span class="p">);</span> <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__defineGetter__</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="s1">'get'</span> <span class="k">in</span> <span class="nx">desc</span><span class="p">))</span> <span class="p">{</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__defineGetter__</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">get</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__defineSetter__</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="s1">'set'</span> <span class="k">in</span> <span class="nx">desc</span><span class="p">))</span> <span class="p">{</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__defineSetter__</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">set</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="s1">'value'</span> <span class="k">in</span> <span class="nx">desc</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}());</span>
</code></pre>
</div>

<p>因为IE8部分支持了这个方法（只支持DOM Object），所以这里的检测调用了一次，并用了个<code class="highlighter-rouge">try catch</code>来返回值。</p>

<p>这里在能够使用IE8自带的情况下返回自带的。</p>

<p>然后就是使用了两个已经被废弃的函数。<code class="highlighter-rouge">__defineGetter__</code>和<code class="highlighter-rouge">__defineSetter__</code>来操作访问器属性，但是那些enumerable，writable就不行了。</p>

<h3 id="objectdefineproperties">Object.defineProperties</h3>
<p>这里就是对传入的properties进行for in，然后用hasOwnProperty检测一下。再调用上面的Object.defineProperty。</p>

<h3 id="objectkeys">Object.keys</h3>
<p>返回的自己的可枚举的属性。</p>

<p>这个就是标准的使用for in，再使用hasOwnProperty。</p>

<p><code class="highlighter-rouge">for in</code>会返回所有的可枚举的属性，包括原型链上的。</p>

<h3 id="functionprototypebind">Function.prototype.bind</h3>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">"Bind must be called on a function"</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">slice</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">,</span>
        <span class="nx">args</span> <span class="o">=</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
        <span class="nx">bound</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">nop</span> <span class="p">?</span> <span class="k">this</span> <span class="p">:</span> <span class="nx">o</span><span class="p">,</span>
                            <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)));</span>
        <span class="p">};</span>

    <span class="kd">function</span> <span class="nx">nop</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// native functions don't have a prototype</span>
      <span class="nx">nop</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">nop</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
    <span class="nx">bound</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">nop</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">bound</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>
<p>bind方法IE9之后才加入的，也就是说一般情况下都不能用咯</p>

<p>这个方法直接抄的mozilla官网的，不过写的相当帅气，把一些边界情况考虑的相当完美了。</p>

<p>这里的三目运算符本来百思不得其解的，最后参考了<a href="http://stackoverflow.com/questions/5774070/mozillas-bind-function-question/5774147#5774147">stackoverflow</a></p>

<ul>
  <li>判断typeof是因为一般情况下只有function可以执行这个，但是有人强行改变类型调用的话，这里就能阻止住。</li>
  <li>判断self.prototype，是因为原生的一些function是没有prototype的，这个很有意思!!!</li>
  <li>这里之所以用concat是因为bind返回的还是一个函数，需要支持他调用时的参数</li>
</ul>

<p>至于这里为什么要绕一个大弯，因为他想要让bind方法适用于<code class="highlighter-rouge">new</code>，想让他作为一个constructor来应用，这里参见<a href="http://stackoverflow.com/questions/5774070/mozillas-bind-function-question/5774147#5774147">stack_overflow</a>,才开始百思不得其解，最后发现自己还是太年轻了，这里的写法都还是讲道理的。</p>

<h3 id="arrayisarray">Array.isArray</h3>
<p>用来判断是不是array的方法</p>

<p>就是通过原生的Object.prototype.toString.call([]) == ‘[object Array]’来判断的，其实也可以在判断了length是不是数字之后再看下length是不是可枚举的，因为原生的arry的length是不可枚举的。</p>

<h3 id="arrayprototypeindexoflastindexof">Array.prototype.indexOf和lastIndexof</h3>
<p>ie9以上才能用</p>

<p>这里拿this.length的时候用了this.length »&gt; 0,这一句是位操作符，是针对数字的，功能是</p>

<ul>
  <li>将所有的非数值转化为0</li>
  <li>将数值所有大于等于0的数取整数部分</li>
</ul>

<p>这样做太安全了，到底有没有价值也不知道。</p>

<p>在进行对比之前，还判断了<code class="highlighter-rouge">index in array</code></p>

<p>其他的就是很正常的实现，for循环进行比较，lastIndexOf类似，只是换成了从后面查找而已</p>

<h3 id="arrayprototypeeverysomeforeachmapfilterreducereduceright">Array.prototype.every;some;foreach;map;filter;reduce;reduceRight</h3>
<p>ie9以上才能用</p>

<p>正好复习了一下这几个函数的功能，写法没有什么特别之处，就是for循环进行call的调用</p>

<ul>
  <li>every就是对数组的每一项执行传入的函数，如果所有的都返回true，才返回true，否则返回false。</li>
  <li>some就是数组中只要有一个符合就会返回true，否则返回false</li>
  <li>foreach就是对每一项进行调用</li>
  <li>map返回了一个新的数组，将数组每个元素执行方法得到的结果组成一个新数组返回回来</li>
  <li>filter返回一个执行之后为true的数组，就是将每一个执行，如果为true就添加进结果</li>
</ul>

<h3 id="arrayprototypereducearrayprototypereduceright">Array.prototype.reduce和Array.prototype.reduceRight</h3>
<p>函数的功能是从左向右合并通过函数合并，传入的参数除了callback，还有一个初始项。</p>

<p>两个的写法很正常，就是简单的实现而已。</p>

<p>之所以比较长是因为做的很安全，各种检测，包括传入的是不是函数，调用的是不是array等。</p>

<h3 id="stringprototypetrim">String.prototype.trim</h3>
<p>这个比较简单，但是这边使用的是+号挺有意思的</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="nb">String</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^</span><span class="se">\s</span><span class="sr">+|</span><span class="se">\s</span><span class="sr">+$/g</span><span class="p">,</span> <span class="s1">''</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="datenowdateprototypetoisostring">Date.now和Date.prototype.toISOString</h3>
<p>Date的这两个居然还得IE9</p>

<p>就是Number(new Date())</p>

<p>而toISOString就是返回ISO格式的日期，类似于<code class="highlighter-rouge">2011-10-05T14:48:00.000Z</code></p>

<p>实现就是getUTCFullYear这种都支持的来拼装一下就行了</p>

<h3 id="es5polyfill">到此es5的polyfill就看完了</h3>
<p>但是没有JSON的实现，JSON对象在IE7以下是没有用的，这里作者推荐使用<a href="https://github.com/douglascrockford/JSON-js">JSON-js</a>。</p>

<p>overline</p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">Front-end-learning</a> is maintained by <a href="http://yourhomepage.com">panyifei</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span>
</footer>


    </section>

  </body>
</html>
