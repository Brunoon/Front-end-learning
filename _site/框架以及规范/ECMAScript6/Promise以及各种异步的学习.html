<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>Front-end-learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">Front-end-learning</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>


    <section class="main-content">
      
      <h1 id="promise">Promise以及各种异步的学习</h1>
<p>Promise是一个对象，用来传递异步操作，代表了某个未来才会知道的结果。</p>

<h3 id="section">特点：</h3>

<ul>
  <li>只有<code class="highlighter-rouge">异步操作的结果</code>可以决定这个对象的哪种状态，包括pending，resolved，rejected，外界无法对它造成影响</li>
  <li>一旦状态改变了，就会维持这个结果<code class="highlighter-rouge">不会再变</code>，你可以一直拿到这个结果</li>
</ul>

<h3 id="section-1">主要的功能</h3>
<p>有了promise，可以将一些异步操作以同步的形式保存下来，<code class="highlighter-rouge">避免层层嵌套</code></p>

<h3 id="section-2">缺点</h3>
<ul>
  <li>无法取消</li>
  <li>不设置回调，内部的错误就无法反映到外部</li>
  <li>pending状态很长，我们不知道是即将完成还是刚刚开始</li>
</ul>

<p>如果某些事件不断重复发生，可以用stream模式</p>

<h3 id="section-3">具体的使用</h3>

<h4 id="section-4">创建实例</h4>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... some code</span>

  <span class="k">if</span> <span class="p">(</span><span class="cm">/* 异步操作成功 */</span><span class="p">){</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>
</div>

<p>传入一个函数生成promise对象，两个参数分别是<code class="highlighter-rouge">resolve</code>和<code class="highlighter-rouge">reject</code>（由js引擎提供，不用自己部署）</p>

<p>实例生成过后</p>

<h4 id="then">then方法</h4>
<p>指定成功以及失败时的<code class="highlighter-rouge">回调函数</code>，第二个是可选的，不一定要提供，这个东西可以在catch方法中做</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// success</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// failure</span>
<span class="p">});</span>
</code></pre>
</div>

<h4 id="section-5">简单的例子</h4>

<p>function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, ms, ‘done’);
  });
}</p>

<p>timeout(100).then((value) =&gt; {
  console.log(value);
});</p>

<p>就是<code class="highlighter-rouge">timeout</code>函数return的promise里面有个定时器，时间到了执行<code class="highlighter-rouge">resolve</code>，将‘done’传进去，然后用then来指定对应的resolved，输出传入的value。</p>

<h4 id="section-6">异步加载图片的例子</h4>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">loadImageAsync</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
    <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">image</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'Could not load image at '</span> <span class="o">+</span> <span class="nx">url</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>

<p>就是在onload和onerror事件的时候调用resolved和reject</p>

<h4 id="ajax">Ajax操作的例子</h4>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">getJSON</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"GET"</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">"json"</span><span class="p">;</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s2">"Accept"</span><span class="p">,</span> <span class="s2">"application/json"</span><span class="p">);</span>
    <span class="nx">client</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">handler</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">statusText</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">promise</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">getJSON</span><span class="p">(</span><span class="s2">"/posts.json"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Contents: '</span> <span class="o">+</span> <span class="nx">json</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'出错了'</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>
</div>

<p>就是在监听statuscode的时候区分调用了下resolved和reject</p>

<h4 id="resolvepromise">resolve传入promise实例</h4>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
  <span class="c1">// ...</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
<span class="p">})</span>
</code></pre>
</div>

<p>这里p2的状态依赖p1的状态，只有p1改变了，p2才会跟着改变</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'fail'</span><span class="p">)),</span> <span class="mi">3000</span><span class="p">)</span>
<span class="p">})</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">p1</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">p2</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span>
<span class="nx">p2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span>
<span class="c1">// Error: fail</span>
</code></pre>
</div>

<ul>
  <li>这里p2在1秒后调用resolve，但是p1没变，所以等待；</li>
  <li>3秒后，p1变成reject，p2也就变成了reject</li>
  <li>这里返回的结果p3是可以拿得到的</li>
</ul>

<h4 id="then-1">then方法</h4>

<p><code class="highlighter-rouge">then方法</code>返回的是一个新的promise的实例</p>

<p>所以可以<code class="highlighter-rouge">链式写法</code>，在then之后再调用then</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">getJSON</span><span class="p">(</span><span class="s2">"/post/1.json"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="nx">funcA</span><span class="p">(</span><span class="nx">comments</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Resolved: "</span><span class="p">,</span> <span class="nx">comments</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span> <span class="nx">funcB</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Rejected: "</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>
</div>

<h4 id="catch">catch方法</h4>

<p>catch其实就是一个<code class="highlighter-rouge">.then(null,rejection)</code></p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">getJSON</span><span class="p">(</span><span class="s2">"/post/1.json"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">getJSON</span><span class="p">(</span><span class="nx">post</span><span class="p">.</span><span class="nx">commentURL</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comments</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// some code</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 处理前面三个Promise产生的错误</span>
<span class="p">});</span>
</code></pre>
</div>

<p>这里的话，有3个promise，getJSON本身，然后两个then方法得到的promose，这里的抛出的错误，以及变化成rejected都是可以在最后被catch住的。</p>

<ul>
  <li>catch是会冒泡的，只要在最后写个catch就能拿到</li>
  <li>catch返回的还是一个promise</li>
  <li>Promise的错误不会传递到外层代码，如果不catch，直接消失</li>
</ul>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s2">"ok"</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'test'</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">});</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">});</span>
<span class="c1">// ok</span>
<span class="c1">// Uncaught Error: test</span>
</code></pre>
</div>

<p>这里报错是因为promise已经执行结束了，这里的错误会被抛出到函数体外，讲道理的话，不会这么写…</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'unhandledRejection'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
<span class="p">});</span>
</code></pre>
</div>

<p>nodejs里面的unhandledRejection事件，专门监听未捕获的reject错误</p>

<h4 id="all">all方法</h4>
<p>将多个promise的实例，包装成一个新的promise实例。（可以不是数组，但是得具有iterator接口，且返回的都是Promise对象，如果不是，会先调用Promise.resolve方法，将参数转化为Promise实例）</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span><span class="nx">p2</span><span class="p">,</span><span class="nx">p3</span><span class="p">]);</span>
</code></pre>
</div>

<ul>
  <li>必须全成功才会成功，成功之后，结果会成为数组，传给回调</li>
  <li>有一个失败了就失败了，第一个被reject的实例的返回值传给p的回调</li>
</ul>

<h4 id="race">race方法</h4>

<p>var p = Promise.race([p1,p2,p3]);</p>

<p>有一个改变了状态，p的状态就跟着变，然后他的值会传递给p的回调</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="s1">'/resource-that-may-take-a-while'</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'request timeout'</span><span class="p">)),</span> <span class="mi">5000</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">])</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">))</span>
<span class="nx">p</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span>
</code></pre>
</div>

<p>这里的例子就是加了个timeout的设置</p>

<h4 id="resolve">resolve方法</h4>
<p>这个方法将现有的对象装化为promise对象，可不带参数
就是看有没有then方法，如果没有，直接就是状态为resolved的promise</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">});</span>
<span class="c1">// Hello</span>
</code></pre>
</div>
<ul>
  <li>如果是promise的实例，那就直接返回实例</li>
</ul>

<h4 id="reject">reject方法</h4>
<p>Promise.reject()返回一个新的promise，且实例状态为rejected</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="s1">'出错了'</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">reject</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">))</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">});</span>
</code></pre>
</div>

<h4 id="section-7">应用</h4>
<p>加载图片</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kr">const</span> <span class="nx">preloadImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">image</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
    <span class="nx">image</span><span class="p">.</span><span class="nx">onload</span>  <span class="o">=</span> <span class="nx">resolve</span><span class="p">;</span>
    <span class="nx">image</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">reject</span><span class="p">;</span>
    <span class="nx">image</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">path</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre>
</div>

<p>异步的四种：
1.回调
2.事件监听
3.发布/订阅
4.Promise对象</p>

<p>1最以前就是回调函数了，但是一层层的写，很容易callback hell
4所以promise可以把代码写成纵向的加载，最大的问题，代码冗余，无论什么，被包装了都是一堆的then
generator函数就是将控制权抛了出去</p>

<p>tudo：stream模式是个啥？
tudo:多个then在一起，其中一个出了错，剩下的还会执行吗？还是直接到catch的地方？
tudo:如果不catch，是不是直接挂掉？catch里面的例子测试一下
tudo:resovle方法如果有then的话会发生什么呢？</p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">Front-end-learning</a> is maintained by <a href="http://yourhomepage.com">panyifei</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span>
</footer>


    </section>

  </body>
</html>
