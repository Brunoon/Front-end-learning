<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <p>#正则表达式</p>

<p><a href="https://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=true&amp;spec=true&amp;code=">babel在线运行地址</a></p>

<p>##构造函数的修改
以前的构造函数只支持<code class="highlighter-rouge">字符串</code></p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="s1">'xyz'</span><span class="p">,</span><span class="s1">'i'</span><span class="p">);</span>
	<span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/xyz/i</span><span class="p">;</span>
</code></pre>
</div>

<p>现在的接受<code class="highlighter-rouge">正则表达式</code>作为参数，就是传入正则表达式的拷贝。</p>

<p>如果有第二个参数的话，则将会覆盖<code class="highlighter-rouge">原修饰符</code>，如果没有的话，则使用传入的表达式的修饰符。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="sr">/xyz/ig</span><span class="p">,</span><span class="s1">'g'</span><span class="p">);</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">regex</span><span class="p">.</span><span class="nx">flags</span><span class="p">);</span><span class="c1">//g</span>
</code></pre>
</div>

<p>##新的修饰符
###u修饰符
<code class="highlighter-rouge">unicode模式</code></p>

<p>用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。
ECMAscript正则表达式支持就不够细致
一直的就不支持4个字节的UTF-16</p>

<ul>
  <li>‘啊’的是\u554a，’啊’.length //1</li>
  <li>‘𠮷’就是\ud842\udfb7，’𠮷’.length //2</li>
</ul>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="o">/^</span><span class="err">\</span><span class="nx">uD83D</span><span class="o">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'\uD83D\uDC2A'</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="sr">/^</span><span class="se">\u</span><span class="sr">D83D/</span><span class="nx">u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'\uD83D\uDC2A'</span><span class="p">)</span>
<span class="c1">//false</span>
<span class="c1">//es5不支持4个字节的UTF-16，会将齐识别为两个字符</span>
</code></pre>
</div>
<p>####.字符
- 正则里面是匹配除了换行符以外的任意字符。
- es5不包括码点大于0xFFFF的Unicode字符，加上了u才能识别</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s2">"𠮷"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sr">/^.$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span> <span class="c1">//false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sr">/^.$/</span><span class="nx">u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span> <span class="c1">//true</span>
</code></pre>
</div>

<p>不添加u字符的话，上面的字符串就会被当成两个字符从而匹配失败</p>

<div class="highlighter-rouge"><pre class="highlight"><code>‘𠮷’实际上就是这个\ud842\udfb7
</code></pre>
</div>

<p>####uincode字符表示法</p>

<pre><code class="language-javascipt">/\u{61}/.test('a') // false
//简单的61次u
/\u{61}/u.test('a') // true
//识别为u0061
/\u{20BB7}/u.test('𠮷') // true
//想写超过四位的只能这么表示
</code></pre>

<p>如果想使用这种大括号的形式来表示unicode字符</p>

<ul>
  <li>前面需要加上\u之外</li>
  <li>还需要加上u修饰符</li>
</ul>

<p>####量词</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="o">/</span><span class="nx">a</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span><span class="sr">/.test</span><span class="se">(</span><span class="sr">'aa'</span><span class="se">)</span><span class="sr"> /</span><span class="o">/</span> <span class="kc">true</span>
<span class="sr">/a</span><span class="se">{2}</span><span class="sr">/</span><span class="nx">u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'aa'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="sr">/𠮷</span><span class="se">{2}</span><span class="sr">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'𠮷𠮷'</span><span class="p">)</span> <span class="c1">// false</span>
<span class="c1">//  /\ud842\udfb7{2}/.test('\ud842\udfb7\ud842\udfb7’);</span>
<span class="sr">/𠮷</span><span class="se">{2}</span><span class="sr">/</span><span class="nx">u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'𠮷𠮷'</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre>
</div>

<p>也就是下面的情况是可以的
console.log(/𠮷{2}/.test(‘\ud842\udfb7\udfb7’)); //true</p>

<p>####预定义模式</p>

<p>/^\S$/.test(‘𠮷’) // false
/^\S$/u.test(‘𠮷’) // true</p>

<p>\S能够识别非空白字符，然后通过u修饰符可以正确地将两位的UTF-16识别为一位，故而匹配了
与此相同的还有\D(非数字),\W</p>

<div class="highlighter-rouge"><pre class="highlight"><code>\w在正则中可以识别`汉字`，但是ECMA的正则实现不全面，不能匹配汉字。
</code></pre>
</div>

<p>####i修饰符
如果想识别非规范的字符，必须得加上u</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="o">/</span><span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">z</span><span class="p">]</span><span class="o">/</span><span class="nx">i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'\u212A'</span><span class="p">)</span> <span class="c1">// false</span>
<span class="sr">/</span><span class="se">[</span><span class="sr">a-z</span><span class="se">]</span><span class="sr">/i</span><span class="nx">u</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">'\u212A'</span><span class="p">)</span> <span class="c1">// true</span>
</code></pre>
</div>

<p>###y修饰符
“粘连”（sticky）修饰符，表现与<code class="highlighter-rouge">g修饰符</code>很像，g只要剩下的存在匹配就行，但是y要求必须从剩下的第一位开始匹配</p>

<div class="highlighter-rouge"><pre class="highlight"><code>注意第一次也必须从lastindex匹配，也就是默认的0开始
</code></pre>
</div>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s2">"aaa_aa_a"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="sr">/a+/g</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="sr">/a+/</span><span class="nx">y</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>babel，traceur几个转换器暂未支持，还是firefox给力
</code></pre>
</div>

<p>###sticky属性
与y修饰符相匹配，这个表示是否设置了y</p>

<p>###flags属性
会返回正则表达式的修饰符
就和source属性会返回表达式的正文一样</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// 返回正则表达式的修饰符</span>
<span class="sr">/abc/ig</span><span class="p">.</span><span class="nx">flags</span>
<span class="c1">// 'gi'</span>
<span class="sr">/abc/ig</span><span class="p">.</span><span class="nx">sources</span>
<span class="c1">//abc</span>
</code></pre>
</div>

<p>###字符串的正则方法
字符串对象使用正则表达式的四个方法:
match，replace，search，split</p>

<p>ES6在语言的内部改为了使用RegExp的实例方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>所有与正则相关的方法，都定义到了RegExp对象上
</code></pre>
</div>

<p>###RegExp.escape
静态方法是来将字符串转义成正则模式的。
并没有成为6或者7的官方方法，只是有这个需求。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>就是将一些保留字符进行转义
</code></pre>
</div>

<p>参考自阮一峰的<a href="http://es6.ruanyifeng.com/#docs/regex">ECMAScript6入门</a></p>

<p>todo： i修饰符中有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K?
todo： 再细一点
todo： 文字编码</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Theme by <a href="https://github.com/pietromenna">Pietromenna</a>
	</p>
</footer>

    </section>
  </body>
</html>
