<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="UTF-8">
  <title>Front-end-learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">Front-end-learning</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>


    <section class="main-content">

      <h1 id="requirejs">Requirejs源码阅读</h1>
<p>接着上文的<a href="https://github.com/panyifei/learning/blob/master/框架以及规范/模块引入/Requirejs学习以及实现.md">学习以及尝试实现</a>,准备好好看下源码的实现。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var requirejs, require, define;
(function (global, setTimeout){...}(this ,setTimeout));
</code></pre>
</div>

<p>整体结构就是放出了3个全局的变量，然后在一个匿名函数中对3个变量进行赋值。这里把this和setTimeout传进去应该是历史原因，怕这些东西被改写</p>

<p>然互看匿名函数的整体的结构：</p>

<ul>
  <li>最先申明了一些简写以及使用到的正则以及浏览器属性的判断。</li>
  <li>然后申明了一些简单的辅助方法，包括一些循环，还有对象的检测。</li>
  <li>然后是一个主要的方法newContext。这个很长，慢慢看。</li>
  <li>然后申明了require方法</li>
  <li>然后调用了req({});进行了最初的初始化</li>
  <li>然后遍历拿到script，来得到data-main的入口，与我的写法一样</li>
  <li>然后申明了define方法</li>
  <li>然后再执行了一次req(cfg);用配置好的cfg</li>
</ul>

<h2 id="section">执行的主要流程</h2>
<p>主要是就是执行了一次req({});然后初始化了cfg，然后再执行了一次req(cfg)。</p>

<p>这里函数执行的比较复杂，我花了一些时间画了一个图，画的精疲力尽：</p>

<p><img alt="requirejs实现整理" width="800px" src="pics//requirejs.png" /></p>

<p>图里面其实已经画的很详细了，我的图只是其中一种执行的顺序，简单总结就是</p>

<ul>
  <li>第一次req()初始化环境</li>
  <li>第二次req()开始加载入口的模块</li>
  <li>define函数实际上往全局的队列推入</li>
  <li>模块加载好了会执行onScriptLoad方法，然后进行一层层的事件通知(注意事件是绑在依赖的模块上的，出发后，执行父模块的回调，然后再emit调用父模块的回调)</li>
  <li>内部还是有轮询在检测是否加载完的，我个人认为这是在处理error事件，因为整体的执行并不依赖于这个轮询</li>
  <li>他内部支持commonjs的方式其实就是用个正则表达式来进行检索，然后推入deps正常加载而已。就是个形式而已</li>
</ul>

<p>## 小的tip
 nextTick里面的4ms是因为<a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers">html5的规范</a>要求的;最大值的话是2的32次方-1，如果超过了，会被立即执行。</p>

<h2 id="rjs">r.js</h2>
<p>其实这个就是个与requirejs一起用的打包以及压缩的工具。他帮助合并了requirejs异步发出的请求，然后还用uglify压缩了一下。</p>

<p>参考：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://www.cnblogs.com/yexiaochai/p/3632580.html

http://www.cnblogs.com/zhiyishou/p/4770013.html

http://www.nihaoshijie.com.cn/index.php/archives/381
</code></pre>
</div>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">Front-end-learning</a> is maintained by <a href="https://github.com/panyifei">panyifei</a>.</span>
</footer>


    </section>
    <div id="disqus_thread"></div>
    <script>
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = '//panyifei.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>
  </body>
</html>
