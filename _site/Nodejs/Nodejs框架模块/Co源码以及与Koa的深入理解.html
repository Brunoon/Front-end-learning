<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>


    <section class="main-content">

      <h1 id="cokoa">Co源码以及与Koa的深入理解</h1>
<p>tj大神的co，将本来应该是一个数据类型的generator变成了一种处理异步的解决方案</p>

<p>其实主要就是一个遍历函数，将promise或者generator的异步函数一直执行到得到最后的结果再返回，这样就可以把本来放到异步中的方法按照同步的顺序来写。</p>

<h2 id="yield">yield</h2>
<p>函数内部的yield后面传入的可以是以下</p>

<ul>
  <li>Promise(就是promise嘛)</li>
  <li>thunks(就是一个偏函数，执行之后只有一个简单的拥有一个callback的参数的函数)</li>
  <li>array(通过array可以并行执行里面的function，<code class="highlighter-rouge">并行</code>是主要的价值)</li>
  <li>objects(和array相同，也是并行执行里面的yieldable，<code class="highlighter-rouge">并行</code>是主要的价值)</li>
  <li>generators</li>
  <li>generators functions(下面的这两个东西可以支持，但是并不被推荐，因为我们应该转向更加标准的promise)</li>
</ul>

<h2 id="api">API</h2>
<p>### co(fn*).then
将一个generator解决为一个promise</p>

<h3 id="var-fn--cowrapfn">var fn = co.wrap(fn*)</h3>
<p>讲一个generator转化为一个返回promise的常规函数</p>

<h2 id="section">本质的探索</h2>
<p>他的最初实现是基于Thunk函数的。接收了一个生成器函数作为参数，并生成了一个实际操作函数，函数通过接收回调的方式来传入最后的返回值。</p>

<h2 id="thunk">所以先了解下thunk函数</h2>
<p>这东西的发展是由函数的求值策略的分歧决定的，两种求值策略</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">){</span>
   <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="nx">a</span><span class="p">(</span><span class="nx">b</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>上面的代码一<code class="highlighter-rouge">b+1</code>在什么时候执行比较好，</p>

<p>一种是传值调用，在进入函数体之前就直接执行完，把值传进去。c语言是这么做的</p>

<p>一种是传名调用，将表达式传入函数体，只在用到他的时候求值。Hskell语言是这么做的</p>

<p>前一种会简单一些，但是会有性能损失，所以倾向于传名调用。</p>

<p>传名函数的编译器实现，其实就是放入一个临时函数，再将临时函数传入函数体，这个临时函数就叫做thunk函数。</p>

<p>js语言是传值调用，他的thunk含义有些不同，js中，thunk函数替换的不是表达式，而是多参数函数，将它替换成单参数的版本，且只接受回调函数作为参数。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="c1">//正常的readFile函数</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fileName</span><span class="p">);</span>
  <span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
  <span class="c1">//thunk版本的函数</span>
  <span class="kd">function</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fileName</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span><span class="nx">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre>
</div>

<p>所以其实任何有回调的函数都是可以搞成thunk形式的，下面是一个简单的生成器</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="kd">var</span> <span class="nx">Thunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="c1">//先传入其他的参数初始化</span>
      <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
      <span class="c1">//传入callback返回的函数</span>
      <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
        <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
        <span class="c1">//实际调用的时候</span>
        <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">args</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">readFileThunk</span> <span class="o">=</span> <span class="nx">Thunk</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
  <span class="nx">readFileThunk</span><span class="p">(</span><span class="nx">fileA</span><span class="p">)(</span><span class="nx">callback</span><span class="p">);</span>
</code></pre>
</div>

<p>tj的thunkify源码
<code class="highlighter-rouge">javascript
/**
 * Module dependencies.
 */
var assert = require('assert');
/**
 * Expose `thunkify()`.
 */
module.exports = thunkify;
/**
 * Wrap a regular callback `fn` as a thunk.
 *
 * @param {Function} fn
 * @return {Function}
 * @api public
 */
function thunkify(fn){
  assert('function' == typeof fn, 'function required');
  return function(){
    //这里就是将所有的参数放进了一个新的数组，这里之所以不用[].slice。是因为有人在bluebird docs发现，如果直接这样泄露arguments，v8的一些优化的编译会被搁置，就会有性能上的损失。
    var args = new Array(arguments.length);
    var ctx = this;
    for(var i = 0; i &lt; args.length; ++i) {
      args[i] = arguments[i];
    }
    return function(done){
      //这里用called是为了标记只执行了一次，类似于promise的resolve和reject只能执行一次一样。
      var called;
      args.push(function(){
        if (called) return;
        called = true;
        //因为arguments是一个list，必须得用apply才能在done传入。
        done.apply(null, arguments);
      });
      //这里用个try catch，可以在执行失败时走一遍callback，传入err信息
      try {
        fn.apply(ctx, args);
      } catch (err) {
        done(err);
      }
    }
  }
};
</code></p>

<p><img alt="不用slice处理arguments" width="700px" src="..//pics//pic1.png" /></p>

<p><img alt="为了使回调函数只执行一次" width="700px" src="..//pics//pic2.png" /></p>

<h2 id="generator">generator函数的回调流程管理</h2>
<p>包装成这样到底有个啥用场？用在了generator的流程管理</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">thunkify</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'thunkify'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nx">thunkify</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">'/etc/fstab'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">'/etc/shells'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="nx">r1</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="nx">r2</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre>
</div>

<p>就如同上面的，generator的执行过程实际上是将同一个回调函数，反复传入next的value结果中。这样我们就可以递归的来自动完成这个过程了。于是据诞生了基于thunk函数的执行器，也就是co了。</p>

<h2 id="co">最简单的co</h2>
<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">next</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>
</code></pre>
</div>

<p>执行器帮我们不停地调用传入生成器的next函数，如果done为true的时候，代表迭代完成，会将值传给回调函数。</p>

<p>当然前提是每一个一步函数都得是thunk函数的形式。</p>

<p>thunk并不是generator函数的自动执行的唯一方案。我们需要的其实只是一个机制，循环调用，并且交出和返回程序的执行权，thunk可以做到，promise也可以做到。</p>

<p>首先将readfile包装成promise形式
<code class="highlighter-rouge">javascript
var fs =require('fs');
var readFile  = function(fileName){
  return new Promise(function(resolve,reject){
    fs.readFile(fileName,function(error,data){
      if(error){reject(error)}
      resolve(data);
    })
  });
}
var gen = function* (){
  var f1 = yield readFile('f1.js');
  var f2 = yield readFile('f2.js');
  console.log(f1);
  console.log(f2);
}
</code></p>

<p>然后手动执行下generator函数</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">).</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">})</span>
</code></pre>
</div>

<p>写一个自动执行器</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">gen</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="nx">next</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="co-1">co的源码</h2>

<p>下面的是co源码的逐行阅读，先把参照的一些图片列举出来</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="c1">//array原生的slice</span>
  <span class="kd">var</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">;</span>
  <span class="c1">//这里写的这么古怪就只是想在es6的模块引入时更加舒服一些，参见下面的图片3</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">co</span><span class="p">[</span><span class="s1">'default'</span><span class="p">]</span> <span class="o">=</span> <span class="nx">co</span><span class="p">.</span><span class="nx">co</span> <span class="o">=</span> <span class="nx">co</span><span class="p">;</span>
  <span class="c1">//将传入的generator函数包装成一个返回promise的方法</span>
  <span class="c1">//这是一个独立的方法，就是将传入的函数包装成了co执行前的形式</span>
  <span class="nx">co</span><span class="p">.</span><span class="nx">wrap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//存了一个指针指向原generator函数</span>
    <span class="nx">createPromise</span><span class="p">.</span><span class="nx">__generatorFunction__</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">createPromise</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">createPromise</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">//返回的方法调用就会直接执行co。</span>
      <span class="k">return</span> <span class="nx">co</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">//执行generator或者generator函数然后返回一个promise</span>
  <span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">gen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 将所有的东西放到一个promise里面，来防止引起内存泄露错误的promise chaining。</span>
    <span class="c1">//tudo：看一下这个issue see https://github.com/tj/co/issues/180</span>
    <span class="c1">//参见下面的内存泄露的研究</span>
    <span class="c1">//https://github.com/promises-aplus/promises-spec/issues/179 看的我好累，完全没有看懂啊！！！</span>
    <span class="c1">//总之不管怎样，他是把传进来的东西包装成了一个promise</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//这里是判断下gen是不是函数，generators function执行之后是一个object</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">gen</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
      <span class="c1">//传入的不是generators函数，没有next，就直接resolve返回结果;这里是错误兼容而已，因为co就是基于generator的，传入其他的没有意义</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">gen</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="s1">'function'</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">gen</span><span class="p">);</span>
      <span class="c1">//主要就是走下面的onFulfilled方法，这个方法返回的是一个promise(resolve或者reject)</span>
      <span class="nx">onFulfilled</span><span class="p">();</span>
      <span class="kd">function</span> <span class="nx">onFulfilled</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="c1">//调用第一次next方法</span>
          <span class="nx">ret</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//出错了直接reject出去</span>
          <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//将第一次的结果({done:true,value:{}})传入内部方法next</span>
        <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">//promise失败的时候调用</span>
      <span class="c1">//这里在promise错误的时候，就会尝试向外throw err。Genertor的属性，可以内部抛出，外部不活。如果我们对这个yield进行了try catch，就会被捕获，不处理的话，就会reject出去，在co的catch语句中co(*fn).catch处理。</span>
      <span class="kd">function</span> <span class="nx">onRejected</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="nx">ret</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">//循环得到next的结果，return的还是一个promise</span>
      <span class="kd">function</span> <span class="nx">next</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//如果done为true的话，代表执行结束，返回一个resolve的promise</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
        <span class="c1">//既然还没执行完，就将ret.value转换成一个promise</span>
        <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">toPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
        <span class="c1">//如果成功转化为了promise，就在这个promise执行完了再调用onFulfilled方法</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="nx">isPromise</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">onRejected</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">'You may only yield a function, promise, generator, array, or object, '</span>
          <span class="o">+</span> <span class="s1">'but the following object was passed: "'</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'"'</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">//将yield后面的东西转化成一个promise</span>
  <span class="kd">function</span> <span class="nx">toPromise</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//如果不存在的话，直接返回，走最后的报错流程</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">)</span> <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="c1">//判断传入的是不是promise，是的话直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isPromise</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="c1">//判断传入的是不是generator，或者generator function，是的话，继续调用co函数进行循环~</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isGeneratorFunction</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isGenerator</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="k">return</span> <span class="nx">co</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
    <span class="c1">//如果就是个普通的thunk函数，也把他转化为promise</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">'function'</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">)</span> <span class="k">return</span> <span class="nx">thunkToPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
    <span class="c1">//如果是array或者object的话，也走相应地变换方法</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="k">return</span> <span class="nx">arrayToPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="k">return</span> <span class="nx">objectToPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
    <span class="c1">//如果都不是，直接返回，走最后的报错流程</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//这里将thunk转化成了promise，thunk就是调用的时候传入一个error和res的function，就在最外面包了个promise就行了</span>
  <span class="kd">function</span> <span class="nx">thunkToPromise</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">//这里的array转化为promise其实就是通过Promise.all来包裹，这个方法只接受promise的数组，并且装化为一个新的promise</span>
  <span class="c1">//参见下面的promise平行执行的研究</span>
  <span class="kd">function</span> <span class="nx">arrayToPromise</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">toPromise</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="c1">//将一个object转化为promise，其实就是内部调用了promise.all方法而已</span>
  <span class="kd">function</span> <span class="nx">objectToPromise</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">constructor</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">toPromise</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">promise</span> <span class="o">&amp;&amp;</span> <span class="nx">isPromise</span><span class="p">(</span><span class="nx">promise</span><span class="p">))</span> <span class="nx">defer</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
      <span class="k">else</span> <span class="nx">results</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="kd">function</span> <span class="nx">defer</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// predefine the key in the result</span>
      <span class="nx">results</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="nx">promises</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">results</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">res</span><span class="p">;</span>
      <span class="p">}));</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">//检查是否是promise，果然就是简单的判断他有没有then方法</span>
  <span class="kd">function</span> <span class="nx">isPromise</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'function'</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//这里判断是不是generator就是判断他的next和throw方法是不是function</span>
  <span class="kd">function</span> <span class="nx">isGenerator</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">'function'</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="s1">'function'</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">.</span><span class="k">throw</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//判断是否是generatorFunction就是判断了他的constructor的name</span>
  <span class="kd">function</span> <span class="nx">isGeneratorFunction</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>
    <span class="c1">//这里是为了解决没有constructor的对象，比如Object.create(null)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">constructor</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="c1">//这里两种情况会返回true，一种是名字正确地，一种是他的prototype是generator</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">'GeneratorFunction'</span> <span class="o">===</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="s1">'GeneratorFunction'</span> <span class="o">===</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">displayName</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">isGenerator</span><span class="p">(</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="p">}</span>
   <span class="c1">//就是通过constructor来判断是不是一个简单的对象</span>
  <span class="kd">function</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span> <span class="o">==</span> <span class="nx">val</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre>
</div>

<h3 id="section-1">图片3</h3>
<p><img alt="处理es6模块的引入" width="700px" src="..//pics//pic3.png" /></p>

<h3 id="promise-chaining">promise chaining导致的内存泄露</h3>
<p>这里只是源码的一个小注释，去看了不少东西</p>

<p>阅读了https://github.com/tj/co/issues/180</p>

<p>有人发现在一个无限循环的for循环里面使用co调用一个异步操作，会发生内存泄露</p>

<p>有人推断是所有的promise都被连接了起来，阻止了gc的回收</p>

<p>有人测试了基于thunk的v3，发现ok，v4发现内存泄露，并且使用工具发现确实是promise的问题</p>

<p>死马说这事规范里的问题，bluebird和then/promise已经做出了修复，</p>

<p>最后hax说是es6 spec “bug”</p>

<p>接下来看一个<a href="http://stackoverflow.com/questions/15027192/how-do-i-stop-memory-leaks-with-recursive-javascript-promises">解决方案</a></p>

<p>就是用一个promise从外面包裹住全部，为什么这样有用？？！！</p>

<p>接下来阅读https://github.com/promises-aplus/promises-spec/issues/179</p>

<h3 id="promise">promise的平行执行</h3>
<p>promise被创建的时候就开始了他们的任务，是无法被执行的。他们只代表了结果的状态，将他们传给promise.all的时候甚至都是并行执行的。他不关心执行顺序，也不关心是否平行运行。
tudo:看一下nodejs的多线程？？</p>

<h3 id="co-2">Co的错误处理</h3>
<p>这里主要是涉及到generator.throw方法，可以在generator外部抛出异常，而在generator内部来catch住异常。</p>

<p>co里面使用了这个属性，就可以针对某几个yield进行try catch，如果不进行处理，统一的会在后面的catch语句中<code class="highlighter-rouge">co(*fn).catch</code>找到。</p>

<h3 id="koa">Koa执行的理解</h3>
<p><img alt="洋葱模型" width="600px" src="..//pics//pic4.png" /></p>

<p>请求进来的时候会一次经过各个中间件进行执行，中间件之间的跳转是yield next，执行完了之后就会逆序执行。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="o">*</span><span class="p">(</span><span class="nx">next</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
  <span class="c1">//执行到这句话的时候跳到下一个中间件</span>
  <span class="k">yield</span> <span class="nx">next</span><span class="p">;</span>
  <span class="c1">//下面的中间件执行完了之后再执行下面的部分</span>
  <span class="kd">var</span> <span class="nx">ms</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'%s %s - %s'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span> <span class="nx">ms</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>
</div>

<h4 id="yield-next">写两个yield next会有什么问题？</h4>
<p>这里遇到yield next其实还是会继续向下执行下一个generator的，但是因为下一个中间件done的状态已经是true了，再次调用一下此前已经执行完的generator，调用返回的结果肯定还是done为true，因为此前已经执行完了。所以后面继续yield next是没有意义的~~</p>

<p>Koa的中间件是运行在co函数之下的。</p>

<h4 id="koa-1">Koa的中间件的实现</h4>
<p>这里看到了一个Koa中间件的实现</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">gens</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">function</span> <span class="nx">use</span><span class="p">(</span><span class="nx">generetor</span><span class="p">){</span>
    <span class="nx">gens</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">generetor</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 实现co函数</span>
<span class="kd">function</span> <span class="nx">co</span><span class="p">(</span><span class="nx">flow</span><span class="p">,</span> <span class="nx">isGenerator</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">gen</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isGenerator</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">gen</span> <span class="o">=</span> <span class="nx">flow</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">gen</span> <span class="o">=</span> <span class="nx">flow</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
            <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="c1">// 如果调用完毕，调用resolve</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">){</span>
                <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 如果为yield后面接的为generator，传入co进行递归，并且将promise返回</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span><span class="p">.</span><span class="nx">next</span> <span class="o">===</span> <span class="s2">"function"</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">value</span><span class="p">.</span><span class="k">throw</span> <span class="o">===</span> <span class="s2">"function"</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">value</span> <span class="o">=</span> <span class="nx">co</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">){</span>
                <span class="c1">// 当promise执行完毕，调用next处理下一个yield</span>
                <span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
                    <span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
                <span class="p">})</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="nx">next</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">trigger</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">gens</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">co</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">m</span><span class="o">--</span><span class="p">){</span>
            <span class="c1">// 形成链式generator</span>
            <span class="nx">prev</span> <span class="o">=</span> <span class="nx">gens</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">prev</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 执行最外层generator方法</span>
        <span class="k">yield</span> <span class="nx">prev</span><span class="p">;</span>
    <span class="p">})</span>
<span class="p">}</span>
<span class="nx">use</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(</span><span class="nx">next</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s2">"step1"</span><span class="p">)</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
    <span class="k">yield</span> <span class="nx">next</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"step2"</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">use</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(</span><span class="nx">next</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"step3"</span><span class="p">);</span>
    <span class="k">yield</span> <span class="nx">next</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s2">"step4"</span><span class="p">)</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">use</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="s2">"step5"</span><span class="p">)</span>
        <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"step6"</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">trigger</span><span class="p">();</span>
</code></pre>
</div>

<p>tudo:啥叫链式的generator??</p>

<h4 id="koa-2">Koa的运行顺序图</h4>
<p><img alt="Koa的运行顺序" width="800px" src="..//pics//pic5.png" /></p>

<p>这张图非常详细了，原来本身的respond，以及自己定义的一些中间件统一的会被整成一个generator，然后交给co来执行。</p>

<p>tudo:看到的一个博主说是这里模拟的async和await，这里可以去了解一下??</p>

<p>todu：那个内存泄露的问题看不懂啊，操！！先不管了，要死了</p>

<p>本文引用：</p>

<p><a href="http://segmentfault.com/a/1190000002783230">http://segmentfault.com/a/1190000002783230</a></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html">http://www.ruanyifeng.com/blog/2015/05/thunk.html</a></p>

<p><a href="http://www.cnblogs.com/axes/p/4683176.html">http://www.cnblogs.com/axes/p/4683176.html</a></p>

<p><a href="http://purplebamboo.github.io/2015/01/16/koa-source-analytics-4/">http://purplebamboo.github.io/2015/01/16/koa-source-analytics-4/</a></p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">panyifei</a>.</span>
</footer>


    </section>
    <div id="disqus_thread"></div>
    <script>
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = '//panyifei.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>
  </body>
</html>
