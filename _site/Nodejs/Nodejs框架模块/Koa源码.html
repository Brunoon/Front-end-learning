<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <h1 id="koa">Koa源码</h1>

<p>继着上文的<a href="https://github.com/panyifei/learning/blob/master/Nodejs/Co源码以及与Koa的深入理解.md">Co源码以及与Koa的深入理解</a>，开始学习下Koa是怎么写的。我看的版本是1.1.2的。</p>

<p>从package.json里面看，Koa的入口是application.js，于是先看这个js。</p>

<h3 id="application">application引用的模块</h3>
<p>先从最开始引入的一些模块开始理解。</p>

<ul>
  <li>debug：最开始引了一个外部的debug模块。这是个好东西，只要在运行的时候使用<code class="highlighter-rouge">DEBUG=..</code>就可以了进行代码的调试了，如下图，如果有多个的话可以用逗号分隔开。会有比较好看的风格，主要是用来替换console.log的，看上去更专业点。</li>
</ul>

<p><img alt="debug使用" width="700px" src="..//pics//debug.png" /></p>

<ul>
  <li>events：然后引用了nodejs的内置模块events，将application的prototype设置了下</li>
  <li>composition：外部模块，试验性质。是可以将传入的函数包装成一个promise的。</li>
  <li>主要是支持包括es7的async语法的，如果设置了this.experimental，就会使用这个来执行，否则的话使用co.wrap方法。</li>
  <li>koalization是不是打开了experimental？</li>
  <li>on-finished：外部模块，是在response结束或者失败的时候触发的，如果失败了的话会带个error进来。</li>
  <li>response，request，context：3个内部代码块，都是重新对req，res和context进行了封装。</li>
  <li>koa-compose：外部模块，是个核心方法，将所有的中间件嵌套为循环的genreator，然后就可以交给co去wrap一下变成promise，然后就可以直接执行了。</li>
  <li>koa-is-json：一个小的外部模块，用来检测body是不是json</li>
  <li>statuses：外部模块，简单的http状态码的相互对应而已</li>
  <li>cookies：外部模块，进行cookie的管理</li>
  <li>accepts：外部模块，用来对请求头的accepts进行管理，处理</li>
  <li>assert：外部模块，用来写单元测试的</li>
  <li>stream：内置模块，用来处理流式的数据的</li>
  <li>http：内置模块，用来createServer的</li>
  <li>only：外部模块，用来返回一个新对象，包含只在传入的白名单中的属性</li>
  <li>co：外部模块，前面已经研究过的模块，不再详细记录，参见<a href="https://github.com/panyifei/learning/blob/master/Nodejs/Co源码以及与Koa的深入理解.md">Co</a></li>
</ul>

<p>至此，使用的模块已经清楚，开始看下整个结构。</p>

<h3 id="application-1">application的结构设计</h3>

<p>Application是被抛出去的总入口，是个<code class="highlighter-rouge">构造函数</code>，他的作用是</p>

<ul>
  <li>区分传入的环境参数</li>
  <li>初始化存使用的中间件middleware，一个空数组。</li>
  <li>使用自己的包装过的3个内部代码来初始化上下文，req和res。</li>
</ul>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Application</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//这一句的作用挺精髓的，因为application是一个构造函数，如果没有new调用的话，就return一个new的</span>
  <span class="c1">//这里返回的是new Application，而不是new Application()，是不是有些奇怪，其实这两种写法在没有参数时没有区别，在有参数时，必须加上括号~</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Application</span><span class="p">))</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">Application</span><span class="p">;</span>
  <span class="c1">//这句就是处理环境参数，默认为开发，代码里可以根据env的值来决定访问哪里的数据库，或者错误log的记录地点等等</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">env</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">||</span> <span class="s1">'development'</span><span class="p">;</span>
  <span class="c1">//被忽略的子域名位数，比如ppe.b.dianping.com,他的默认子域名就为['ppe','b']，如果设置为3，子域名就为['ppe']</span>
  <span class="c1">//设置了这个值决定了我们在this.subdomains数组里面可以访问的值</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">subdomainOffset</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//存中间件，下面的app.use方法直接push就好了</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">middleware</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">//这个东西也不知道是啥。。</span>
  <span class="c1">//tudo：X-Forwarded-Proto？？</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">proxy</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="c1">//这三个东西就是作者包装后的上下文，req，res</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">request</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">response</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>app是Application的原型对象。</p>

<p>强行用emitter的原型来替换了application的原型。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">//这样子就继承了事件流</span>
<span class="c1">//然后下面的代码this.on('error',fn)来监听</span>
<span class="c1">//this.emit就可以触发</span>
<span class="c1">//这里想到了点评张老师的cortex里面的模块class也支持implement events这个东西，然后就去看了下他是怎么在browser端支持emitter的，原来是引用了npm的一个模块events</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Application</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">Emitter</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</code></pre>
</div>

<p>然后对app进行原型上的包装。</p>

<ul>
  <li>app.listen：来createServer的，将<code class="highlighter-rouge">this.callback</code>添加到了request事件上~注意是可以调用多次</li>
  <li>app.toJSON：公有方法，将他作为json输出时，会将subdomainOffset，proxy，env这几个值，好像并没有什么用..</li>
  <li>app.use：很清楚，就是往middleware里面push而已，如果没有打开试验选项experimental，就只能传入generator</li>
  <li>app.callback：处理中间件并且进行返回的地方</li>
  <li>app.createContext：私有方法，创建初始化的上下文</li>
  <li>app.onerror：私有方法，默认的错误处理</li>
  <li>respond：用来帮助返回的方法</li>
</ul>

<p>主要的执行就是app.callback了，这里对代码进行注释</p>

<p><code class="highlighter-rouge">javascript
 app.callback = function(){
   //如果打开了实验的接口，就可以使用es7的async,不然使用koa-compose来进行包装，然后再传给co
   var fn = this.experimental
     ? compose_es7(this.middleware)
     : co.wrap(compose(this.middleware));
   var self = this;
   //看是否注册了错误事件，没有的话使用自身的onerror
   if (!this.listeners('error').length) this.on('error', this.onerror);
   return function(req, res){
     res.statusCode = 404;
     //在这里对上下文，以及req和res进行了包装
     var ctx = self.createContext(req, res);
     //注册一下这个是为了处理error
     //当error发生时，调用了context的onerror，里面emit了app的onerror，这样上面的this.onerror就可以被触发了。
     //为什么这东西能够监听到res的error？？
     //tudo：怎么做到的
     onFinished(res, ctx.onerror);
     //然后执行那个co包装过的promise，成功的话执行respond方法，失败了执行this.onerror方法
     fn.call(ctx).then(function () {
       respond.call(ctx);
     }).catch(ctx.onerror);
   }
 };
</code></p>

<p>respond方法也挺有意思，注释一下</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">respond</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="kc">false</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">respond</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">res</span><span class="p">;</span>
  <span class="c1">//如果头部已经发送，或者不能写了，跳过</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">headersSent</span> <span class="o">||</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">writable</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">code</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">status</span><span class="p">;</span>
  <span class="c1">//如果是一些不需要返回体的code，比如204:没有内容，比如304:未修改)，直接返回</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">statuses</span><span class="p">.</span><span class="nx">empty</span><span class="p">[</span><span class="nx">code</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">body</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">//如果是head请求，返回一个length</span>
  <span class="c1">//head请求允许请求某个资源的响应头，而不要真正的资源本身</span>
  <span class="k">if</span> <span class="p">(</span><span class="s1">'HEAD'</span> <span class="o">==</span> <span class="k">this</span><span class="p">.</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isJSON</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">body</span><span class="p">));</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">//如果就是没有内容，就设置一个默认的返回</span>
  <span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">==</span> <span class="nx">body</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">'text'</span><span class="p">;</span>
    <span class="nx">body</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">||</span> <span class="nb">String</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//对不同的响应体进行判断并且返回</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">Buffer</span><span class="p">.</span><span class="nx">isBuffer</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span> <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="s1">'string'</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">body</span><span class="p">)</span> <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">body</span> <span class="k">instanceof</span> <span class="nx">Stream</span><span class="p">)</span> <span class="k">return</span> <span class="nx">body</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
  <span class="nx">body</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">body</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="koa-compose">这里再顺便看一下koa-compose的代码</h3>
<p>代码非常精简，功能是将一堆generator的数组包装成嵌套的generator
tudo:继续看，没看完呢。。。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">compose</span><span class="p">;</span>
<span class="cm">/**
 * Compose `middleware` returning
 * a fully valid middleware comprised
 * of all those which are passed.
 *
 * @param {Array} middleware
 * @return {Function}
 * @api public
 */</span>

<span class="kd">function</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">middleware</span><span class="p">){</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="o">*</span><span class="p">(</span><span class="nx">next</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">next</span><span class="p">)</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">noop</span><span class="p">();</span>

    <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">middleware</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">next</span> <span class="o">=</span> <span class="nx">middleware</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">next</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">yield</span> <span class="o">*</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//私有方法</span>
<span class="kd">function</span> <span class="o">*</span><span class="nx">noop</span><span class="p">(){}</span>
</code></pre>
</div>

<p>//如果想跳过某个中间件？？
//return yield next
//tudo</p>

<p>本文借鉴了</p>

<ul>
  <li><a href="https://github.com/loveky/Blog/issues/3">loveky的博客</a></li>
</ul>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Theme by <a href="https://github.com/pietromenna">Pietromenna</a>
	</p>
</footer>

    </section>
  </body>
</html>
