<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <h1>正则表达式与方法</h1>

<p>JS的正则借鉴的是Perl，通常正则表达式相较于等效的字符串处理有显著的<code>性能优势</code>。</p>

<h2>看个例子</h2>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">parse_url</span> <span class="o">=</span> <span class="sr">/^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Z-a-z]+)(?::(\d))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/</span><span class="p">;</span>
</code></pre></div>
<p>一块块的看，<code>(?:([A-Za-z]+):)?</code>，这里<code>?:</code>代表后面的分组并不捕获(还蛮推荐这么做的，因为捕获会有性能上的缺失)，最后的<code>?</code>代表是可选的，0次或者1次。<code>()</code>这个代表捕获组。</p>

<p><code>(\/{0,3})</code>这个代表0个到3个<code>/</code>。</p>

<p>([0-9.-A-Z-a-z]+)这个主要是里面的<code>.</code>字符，这个字符在外面代表着任意字符，在中括号里面代表着<code>.</code>。中括号里面好像就只有<code>-</code>需要进行转义。</p>

<p>其他的就比较正常了。</p>

<h2>标识</h2>

<ul>
<li>g：全局，匹配多次，(不同的方法对这个的支持不同，exec代表着下次匹配的位置，search会忽略，match会返回所有的匹配结果..)</li>
<li>i：是否区分大小写</li>
<li>m：是否支持多行(^和$能匹配航结束符，使用了m之后，正则表达式就会匹配每行的开头和结尾了)</li>
</ul>

<p>如果我们创建一个正则表达式时使用RegExp的写法的，注意<code>\</code>本身需要转义，也就是说我们使用他来转义时，需要使用两个。因为我是通过字符串的形式传入的，而字符串的\在正则和字符串中有特别的含义，所以这个符号我们需要进行转义。</p>

<h2>RegExp对象的属性</h2>

<ul>
<li>global：如果标识g被使用，值就是true</li>
<li>ignoreCase：如果是i被使用，值为true</li>
<li>lastIndex：下一次exec匹配的索引，初始值为0</li>
<li>multiline：标识m被使用，值为true</li>
<li>source：正则表达式的源码文本</li>
</ul>

<h2>正则表达式的一些元素</h2>

<ul>
<li>分支：|，就是只要匹配任意一个条件，就会被匹配</li>
<li>序列：就是包含一个或多个正则表达式因子，每个因子能选择是否跟随一个量词</li>
<li>正则表达式因子：可以是一个字符，一个圆括号的组，一个字符类，或者一个转义序列</li>
<li>转义：其实就是要背一下咯，\d(匹配一个数字),\w(匹配数字字母下划线),\s(空白符)，\1代表分组1所捕获的文本的引用，这个很好使</li>
<li>分组

<ul>
<li>捕获型：</li>
<li>在圆括号中包住的就是一个捕获组，第一个就是分组1，第二个就是分组2</li>
<li>(?<name>exp)：这种写法就是指定了分组名为name了</li>
<li>非捕获型：就是<code>(?:)</code>这个仅能做简单的匹配，但是不会捕获所匹配的文本</li>
<li>向前正向匹配：<code>(?=)</code>也是非捕获的，即使匹配前面的部分</li>
<li>向前负向匹配：<code>(?!)?</code>类似的，但是他是匹配失败才会继续向前进行匹配。</li>
</ul></li>
<li>字符集：<code>[]</code>就是一组字符的便利方式</li>
<li>转义：就是想匹配特殊字符本身，我们需要加个\来做这件事情</li>
<li>量词：<code>{}</code>就是这个因子要被匹配的次数，注意正则遵守贪婪匹配的原则</li>
</ul>

<h1>方法</h1>

<h2>Array</h2>

<ul>
<li>array.concat():就是复制产生新数组，如果参数是数组，每一项会被单独的添加，并且是浅复制。两个对象如果更改的话会被同时更改。</li>
<li>array.join():这个比使用+号运算符的速度要慢，因为现代的浏览器，包括IE8以后的版本，都对+号连接字符串进行了特别的优化了。</li>
<li>array.pop():就是推出array的最后一个元素并且返回他。</li>
<li>array.push():这个和concat差不多，但是他会整个推入内容，并返回新长度。</li>
<li>array.reverse():这个会反转数组，并返回数组本身</li>
<li>array.shift();移除第一个元素并且返回他，比pop慢多了。</li>
<li>array.slice():就是切割数组，从起始位置到终点位置，只传一个值的话就截到最后，传负值的话就加上length</li>
<li>array.sort():默认就是当做字符串比较，也可以传入比较函数，如果返回的-1，则第一个参数排在前面</li>
<li>array.splice():1参位置，2参删除的个数，后面的都是添加的</li>
<li>array.unshift():就是从前部插入一个值。返回新长度</li>
</ul>

<h2>Function</h2>

<p>apply这个写的太多了</p>

<h2>Number</h2>

<ul>
<li>number.toExponential(小数点位数):就是转化为指数的形式，位数必须为0-20</li>
<li>number.toFixed(小数点位数):转化为十进制的字符串，这个值必须在0-20</li>
<li>number.toPrecision(整体的位数):转化为十进制的字符串，整体的位数必须为0-21</li>
<li>number.toString(几进制):这里控制是几进制显示</li>
</ul>

<h2>Object</h2>

<ul>
<li>object.hasOwnProperty:判断这个属性是不是自带的</li>
</ul>

<h2>RegExp</h2>

<ul>
<li>regexp.exec：最强大和最慢的方法，如果带有g，则查找不是从起始位置，而是lastIndex的位置开始。</li>
<li>regexp.test：最简单的和最快的方法，如果匹配，就返回true，注意g标识是没有用的</li>
</ul>

<h2>String</h2>

<ul>
<li>string.charCodeAt:返回的是那个位置的字符码位，如果小于0或大于等于length，返回NaN，这个蛮奇怪的..</li>
<li>string.charAt</li>
<li>string.concat:这个不如用+号呢</li>
<li>string.indexOf</li>
</ul>

<p>方法很多，就不一个个写了</p>

<p># 代码风格以及特性</p>

<ul>
<li>优秀的程序拥有前瞻性的结构，预见了修改，又不会让其成为过度的负担</li>
<li>清晰的表达方式</li>
</ul>

<p>主要就是良好的习惯，包括空格习惯，tab习惯等等，主要是能够规范编代码。</p>

<h1>优秀特性</h1>

<ul>
<li>函数是顶级对象，有词法作用域的闭包</li>
<li>基于原型链继承的动态对象</li>
<li>对象字面量和数组字面量</li>
</ul>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
