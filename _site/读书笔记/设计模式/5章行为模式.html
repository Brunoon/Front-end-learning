<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>5章行为模式</h1>

<p>涉及到算法和对象间职责的分配，不仅描述对象或类的模式，还描述他们之间的通信模式</p>

<h2>CHAIN OF RESPONSIBILITY(职责链) --对象行为型模式</h2>

<p>意图：就是一个行为沿着一个对象链冒泡，可能会被其中的某个对象处理，使得多个对象都有机会处理对象，避免了发送者和处理者之间的耦合关系。</p>

<p>适用性：</p>

<ul>
<li>多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定</li>
<li>不确定接受者的时候，向多个对象中的一个提交一个请求</li>
</ul>

<p>结构：就是很多个处理者，他们都拥有处理请求的方法并且可以访问到他们的上一级，一个请求从底层向上传递，可能会被其中的一个处理了或者继续向上传递。</p>

<p>效果：</p>

<ul>
<li>降低耦合性：对象无需知道谁来处理，仅仅需要知道这个请求被正确的处理了，接受者和发送者都没有对方的明确信息</li>
<li>不保证被接受</li>
<li>增强了给对象指派职责的灵活性</li>
</ul>

<p>总结：如果这个链经常被修改的话，是可以弄成这个模式的，不一定那种if else的就一定合适，主要还是看项目的演化方向</p>

<h2>COMMAND(命令) --对象行为型模式</h2>

<p>意图：将一个请求封装成一个对象，可以使用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</p>

<p>适用性：</p>

<ul>
<li>在不同的时刻指定，排列和执行请求</li>
<li>支持取消操作，就是command的execute可以顺便存储下状态，然后在取消操作时按照这个状态消除掉操作的影响。</li>
<li>支持修改日志，就是借口提供了添加装载操作以及存储操作，崩溃回复的时候可以拿取这些命令并且重新执行他们。</li>
</ul>

<p>结构：就是客户端声明一些实现的命令对象，并且给他指定好接受者对象。然后发起者拥有这些命令对象。真正的触发由发起者来发起。发起者可以对拥有的这些个命令进行各种排序啊，状态的存储啊等等操作。</p>

<p>总结：就是将一个命令的直接执行过程拆开，分成了发起者和执行者两个角色。然后用一个命令对象来管理他们的关系。通过这个命令对象我们可以存储一些状态，通过这些个状态，我们可以一个是松耦合，一个是支持排队，取消，以及修改以及日志。</p>

<p>效果：</p>

<ul>
<li>将调用操作的对象以及知道如何实现操作的对象解耦</li>
<li>增加新的命令很容易，因为不用改变已有的类</li>
<li>可以将多个命令组装成一个复合命令</li>
</ul>

<h2>INTERPRETER(解释器) --类行为型模式</h2>

<p>意图：</p>

<h2>OBSERVER(观察者) --对象行为型模式</h2>

<p>意图：定义对象之间的一对多的依赖关系，当一个对象状态发生改变的时候，依赖的对象得到通知并自动更新</p>

<p>适用性：</p>

<ul>
<li>当一个对象的改变需要通知多个对象，而且不知道具体有多少</li>
<li>不希望对象之间的紧耦合</li>
</ul>

<p>结构：就是一个抽象对象类，里面有添加和删除观察者的方法，还有通知的方法。具体的对象实现这个类，然后保存有自己内部的状态。有个观察者的抽象，里面只提供了update方法，然后具体的观察者实现抽象类并存有内部的状态。</p>

<p>效果：</p>

<ul>
<li>目标和观察者之间的解耦(这种解耦一般是由于处在不同的层级上，所以需要解耦)</li>
<li>支持广播通信</li>
<li>可能导致意外的更新</li>
</ul>

<p>总结：其实我们js中大部分的观察者都是推模式，但是真正的观察者其实是拉模式。</p>

<h2>STRATEGY(策略) --对象行为型模式</h2>

<p>意图：定义一系列的算法，把他们一个个封装起来，使得他们可以相互替换。使得算法可独立于使用它的客户而变化。</p>

<p>适用性：</p>

<ul>
<li>许多相关的类仅仅是行为有异</li>
<li>需要使用一个算法的不同变体</li>
<li>算法使用用户不应该知道的数据</li>
</ul>

<p>结构：很简单，就是一个上下文聚合了一个抽象的算法。这个算法会有很多种实现。</p>

<p>效果：</p>

<ul>
<li>定义了一系列的可供重用的算法或者行为</li>
<li>替换了继承的能力</li>
<li>消除了一些条件语句</li>
</ul>

<p>总结：这个玩意和桥接模式很像，但是区别还是有的，首先策略是行为模式，而桥接是结构性模式。桥接的的调用方是可以有自己的变化的，而策略模式不能有自己的变化。桥接模式更多的是体系的隔离。可以说桥接模式包含着策略模式。但是桥接模式比策略更加的高级一些。更多的是一种接口隔离的原则，使之可以松散的耦合。主要是看一个问题的角度问题</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-52">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
