<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>3章创建型模式</h1>

<p>创建型模式抽象了实例化过程。帮助系统独立于如何创建，组合和表示他的那些个对象。类创建模式使用继承改变被实例化的类。而对象创建型模式将实例化的操作托付给另一个对象。</p>

<p>随着系统演化得越来越依赖于对象符合而不是类继承。系统使用那些具体的类被封装了。隐藏了这些类的实例是如何被创建和放在一起的。创建型模式什么时候被创建，谁创建，以及怎样被创建都是有自主性的。</p>

<p>有时创建型模式是相互竞争的，也有时候他们是可以互补的。</p>

<p>书里先是举了个创建一个迷宫的例子，就是调用了构造方法。然后使用它的实例来进行各种东西的初始化。</p>

<p>虽然我们可以在构造函数中来提前初始化每一面。(这个目前我认为已经解决了问题了...)但是这样仅仅是把代码移到了别的地方，这样子代码会更小，但是设计没有更灵活。我们一旦改变了布局就得重新写一个构造函数。</p>

<ul>
<li>一种是调用虚函数而不是构造器来创建。我们就可以创建子类并且重定义虚函数。从而改变被例化的类。这是Factory Method模式的一个例子。</li>
<li>通过传入对象来作为参数，可以通过传入不同的参数来改变房间，墙壁和门的类，这是抽象工厂的模式</li>
<li>通过传递一个对象，这个对象可以在迷宫中增加或者减少门房间，墙壁和门。这就是建造者模式的一个例子。</li>
<li>如果由多种原型的房间，墙壁和门对象参数化，可以用不同的对象替换这些原型对象以改变迷宫的构成。这就是Prototype的例子。</li>
<li>Singleton保证了每个游戏只有一个迷宫且所有的游戏对象都可以迅速访问它。</li>
</ul>

<p>## 抽象工厂模式--对象创建型模式
 意图：提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。</p>

<p>就是定义了一个抽象类，这个类定义了一些接口，然后每种想创建的都是具体的子类来实现具体的功能，然后用户们完全根据<code>抽象类提供的接口</code>来使用。客户完全不知道他们使用的是哪些具体类。</p>

<p>适用性：</p>

<ul>
<li>一个系统要独立于他的产品的创建，组合和表示的时候</li>
<li>系统要由多个产品系列的一个来配置</li>
<li>强调一系列产品对象的设计以便联合使用</li>
<li>提供一个产品类库，只想显示他们的接口而不是他们的实现时</li>
</ul>

<p>优缺点：</p>

<ul>
<li>分离了具体的类：将客户与类的实现分离，客户通过他们的抽象接口操纵实例。</li>
<li>使得易于交换产品系列：具体工厂只在初始化的时候，于是我们可以很方便的改变应用的具体工厂</li>
<li>有利于产品的一致性：当系列中产品对象被设计成一起工作的时候，他能保证一次只能使用同一个系列的对象</li>
<li>不能支持新种类的产品：就是抽象工厂如果被扩展的话，会影响到所有的实现。</li>
</ul>

<p>我们使用工厂的时候，可以通过传递一个参数来指示要创建的对象的种类的参数。</p>

<h2>BUILDER(生成器)--对象创建型模式</h2>

<p>意图：将一个复杂对象的构建和他的表示分离，使同样的构建过程可以创建不同的表示。</p>

<p>就是用户使用一个director来根据一定的步骤来调用builder的创建方法，然后用户从builder那里得到最后生成的东西。  </p>

<p>适用性：</p>

<ul>
<li>当创建复杂对象的算法应该独立于对象的组成方式以及装配方式</li>
<li>构造过程必须允许被构造的对象有不同的表示时</li>
</ul>

<p>效果：</p>

<ul>
<li>可以改变一个产品的内部表示：因为提供给导向器的是一个抽象接口，所以产品的表示和内在结构其实是被隐藏的</li>
<li>将构造代码和表示代码分开：就是代码拆离开了，用户可以使用不同的director来在相同构件的基础上构做不同的product</li>
<li>可以使得构造过程更精细的控制：因为是在导向者的控制下进行合成，所以builder的接口会很好的反映产品的构造过程</li>
</ul>

<p>这里说抽象工厂和建造者模式的区别是：builder是一步步构造复杂对象，抽象工厂着重于多个系列的产品对象，抽象工厂直接拿到产品，builder最后拿到。</p>

<h2>工厂方法--对象创建型模式</h2>

<p>意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到他的子类。</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-52">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
