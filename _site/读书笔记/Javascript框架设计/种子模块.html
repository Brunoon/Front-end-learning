<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
  <link rel="import" href="/Front-end-learning/webcomponent/github-card.html">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>种子模块</h1>

<p>核心模块，框架最先执行，必须得有很高的可扩展性，为第一章的内容</p>

<ul>
<li>对象扩展</li>
<li>数组化</li>
<li>类型判断</li>
<li>简单的事件绑定与卸载</li>
<li>无冲突处理</li>
<li>模块加载</li>
<li>domready</li>
</ul>

<h3>命名空间</h3>

<p>首先框架都是运行在一个命名环境中，都会以一个IIFE（立即调用函数表达式）包裹。</p>

<p>没有命名空间的，例如<code>Prototype</code>，<code>mootools</code>，这些都是在原型上进行扩展。</p>

<p>而<code>YUI</code>，<code>EXT</code>则是通过{}来叠罗汉的。</p>

<p><code>jquery</code>独辟蹊径，命名空间是一个函数(参见文底的自问自答)，因为他选择器导向，这样可以接收css来查找并返回一个jquery实例。</p>

<h4>多库共存原理</h4>

<p>其实就是在初始化之前很简单地保存了一下原来全局里的$，然后在自己初始化的时候将这个值重新赋给$，然后再把自己return出来。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">_jQuery</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">jQuery</span><span class="p">,</span><span class="nx">_$</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">$</span><span class="p">;</span>
<span class="nx">jQuery</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">noConflict</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">deep</span><span class="p">){</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">$</span><span class="o">=</span><span class="nx">_$</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">deep</span><span class="p">)</span>
            <span class="nb">window</span><span class="p">.</span><span class="nx">jQuery</span> <span class="o">=</span> <span class="nx">_jQuery</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">jQuery</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre></div>
<h4>对象扩展</h4>

<p>这就是个给对象扩展的机制。
实现的话就是jQuery的<code>extend</code>方法，jQuery支持深复制。</p>

<p>从源码看。主体就是一个<code>for in</code>循环，然后复制对象。然后就是在deep设置为true的时候，对对象进行深层的复制，循环调用一下extend自身。</p>

<h4>数组化</h4>

<p>先是最简单地<code>[].slice.call</code>(参见自问自答)，这个方法可以提供除了IE低版本之外的数组化。因为IE8以及以下的版本nodeList等都不是Object的子类，所以调用这个方法会出错这里的各大框架的处理差不多。就是针对IE做了hack，就是new了一个array，然后遍历，然后取出来往里面推就是了。</p>

<blockquote>
<p>这里的ie8兼容看了半天，最后发现也就是很简单的遍历然后推进了数组而已。IE下纯粹是因为不是Object，所已无法调用方法，只能这样一个个遍历着拿。</p>
</blockquote>

<h4>类型判定</h4>

<p>判断undefined可以===<code>void 0</code>就好了</p>

<p>普通的基本数据类型可以直接<code>typeof</code>判断，object，function可以使用<code>Object.prototype.toString.call()</code>来拿到类似于[object array]的结果。</p>

<h4>domReady</h4>

<p>一般就是<code>DomContentLoaded</code>，因为这个在DOM结构成型之后就会触发。而不像window.onload方法得在资源都下载完毕才会触发。</p>

<p>所以对于支持DomContentLoaded的就是用这个，不支持的旧版本IE就使用下面的著名hack。IE下调用<code>doscroll</code>，因为IE下如果DOM未建完是无法调用的，IE下也可以通过<code>script defer</code>来判断。jquery下不仅监听了DomContentLoaded，还监听额onload，还判断了document的readyState。</p>

<h4>无冲突处理</h4>

<p>很简单，就是先将全局里面的保存一下，然后再在函数中将保存的赋值一下就好了</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">    <span class="kd">var</span> <span class="nx">_jquery</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">jquery</span><span class="p">;</span>
    <span class="nx">noConflict</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">_$</span><span class="err">；这样把存的冲突释放回去</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">deep</span><span class="p">){</span>
            <span class="nb">window</span><span class="p">.</span><span class="nx">jQuery</span> <span class="o">=</span> <span class="nx">_jQuery</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">jQuery</span><span class="err">；</span>
    <span class="p">}</span>
</code></pre></div>
<h2>自问自答</h2>

<ul>
<li><p><code>$</code>到底是个啥？为什么这个函数居然会有变量？</p>

<p>好吧，原来函数也是对象，也是可以有变量和方法的。</p></li>
<li><p><code>[].slice.call</code>的运行机制是什么，以及与Array.prototype.slice.call的区别</p>

<p>slice就是个数组的截取函数，返回是一个数组，<code>slice(0)</code>等于就是复制了一下数组。内部的实现就是根据传入的东西的length来push进一个新的数组中。通过call方法可以将这个数组原型的方法交给别的对象调用，就可以将一个类数组方法转换为真正的数组了。至于[]和Array.prototype，理论上讲是一致的，但是前者多创建了一个数组对象，所以建议使用后者。</p></li>
<li><p><code>void 0</code>这是个什么东西？</p>

<p>这个东西就是执行void后面的语句，然后返回一个undefined</p></li>
</ul>

<p>todo:为什么这种统一命名空间的比原型扩展混得更好一点？</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
