<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>2章HTTP协议</h1>

<p>HTTP协议和TCP/IP里众多协议一样，用于客户端和服务器之间的通信。</p>

<p>HTTP协议规定。请求从客户端发出，服务端响应请求并返回。</p>

<h2>请求报文和响应报文</h2>

<p>请求方法，请求URI，协议版本，可选的请求首部字段和内容实体，如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">POST /form/entry HTTP/1.1
Host:hackr.jp
Connection:keep-alive
Content-Type:application/x-www-form-urlencoded
Content-Length:16
name=ueno&amp;age=37
</code></pre></div>
<p>接受到请求的服务器，会将请求内容的处理结果以响应的形式返回</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">HTTP/1.1 200 OK
Date:....
Content-Length:362
Content-Type:text/html
&lt;!-- 空行分隔 --&gt;
&lt;html&gt;
&lt;!-- .... --&gt;
</code></pre></div>
<p>响应报文是以协议版本，状态码，解释状态码的原因短语，可选的首部响应字段以及实体主体构成</p>

<h2>无状态的协议</h2>

<p>HTTP是不保存状态，即无状态的协议。本身不对请求和响应之间的通信状态进行保存。就是说不做持久化处理。</p>

<p>协议本身不保存之前一些的请求或响应报文的信息。主要是为了处理大量事物，确保协议的可伸缩性。但是很多时候我们其实是需要保存一些状态的，比如用户的登录状态。这个时候就出现了Cookie技术！！</p>

<h2>请求URI定位资源</h2>

<ul>
<li>使用完整的请求URI来访问</li>
<li>在首部字段Host中写明网络域名或IP地址</li>
<li>对服务器本身发出请求，直接以一个*来代替请求URI。</li>
</ul>

<h2>HTTP方法</h2>

<h3>GET：获取资源</h3>

<p>用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的是文本，那就原样返回。如果是CGI那样的程序，就返回经过执行后的输出结果。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">GET /index.html HTTP/1.1
Host：www.hackr.jp
If-Modified-Since：...
</code></pre></div>
<p>返回时间段之后更新过的页面内容，如果没有更新，就以状态码304作为响应返回。</p>

<h3>POST:传输实体主题</h3>

<p>POST方法用来传输实体的主体</p>

<p>虽然GET方法也可以传输实体的主体，但是我们一般都是使用POST，虽然POST与GET很相似，但是POST主要不是为了获取响应的主题内容</p>

<h3>PUT:传输文件</h3>

<p>用来传输文件的，在请求报文的主体包含文件内容，然后包含到请求的URI指定的位置。主要是协议的PUT方法不带验证机制，存在安全性问题。一般不适用，如果配合验证机制。或者架构采用REST标准，可能会开放PUT方法。</p>

<p>一般的返回就是个204，代表成功了，但是没有数据返回。</p>

<p>最开始的时候只有文件服务器的概念，所以才会有这些个名字的方法，所以所有的方法都是不安全的，鉴权这层肯定得自己做的。REST服务只是一种习惯。</p>

<h3>HEAD:获得报文首部</h3>

<p>与GET方法类似，不过他不用获得报文主体的内容，用于确认URI的有效性和资源更新的日期时间</p>

<p>比如请求了某个html，最后返回的就是有关的响应首部</p>

<h3>DELETE：删除文件</h3>

<p>用来删除文件，与PUT相反，DELETE就是按请求的URI删除指定的资源。，同样不带验证机制。</p>

<h3>OPTIONS：询问支持的方法</h3>

<p>查询针对请求的URI指定的资源支持的方法</p>

<h3>TRACE：追踪路径</h3>

<p>就是发送请求的时候，带个Max-Forwards,每经过一个服务器端就将数字减1，当为0的时候，停止继续传输。主要是为了查询发出去的请求是怎样被加工修改/篡改的。很少会使用。</p>

<h3>CONNECT：要求使用隧道协议连接代理</h3>

<p>要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</p>

<p>这个方法就是HTTPS时代出现的，因为我们使用代理的时候，代理拿到的是加密后的数据，不知道往哪里发，所以先发一个connect请求，告诉代理我要连接这个地址，然后发过来的加密报文就直接发过去了。就是一个隧道了。</p>

<h3>link和unlink已经被HTTP1.1废弃了</h3>

<h3>持久化链接</h3>

<p>就是TCP连接只建立一次，然后不断地请求，响应，都不需要建立重复的连接。这里的连接实际上是TCP连接，一般会有个限制时间，几秒内有请求就不会断开。</p>

<h3>管线化</h3>

<p>持久连接使得管线化方式成为可能，就是可以同时并行发送多个请求，不需要一个一个等待响应。这个是浏览器实现的吧。</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-52">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2017
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
