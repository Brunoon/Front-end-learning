<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
    <h1 class="project-name"><a href="/Front-end-learning/README">前端技术</a></h1>
    <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
    <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
    <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
</section>

    <section class="main-content">
      <h1>21Ajax和Comet</h1>

<p>Ajax通信与格式无关，就是XHR来异步拉取数据，然后通过DOM来操作原页面。</p>

<h2>创建XHR对象</h2>

<p>一般直接<code>new XMLHTTPRequest()</code>就行了，为了兼容IE7之前的话，需要用<code>new ActiveXObject(&#39;MSXML2.XMLHttp&#39;)</code>来生成。//这里的里面的内容是有三种的</p>

<h2>XHR的用法</h2>

<h3>open方法</h3>

<p>第三个参数代表是否异步发送。
<code>javascript
xhr.open(&#39;get&#39;,&#39;example.html&#39;,false);
</code></p>

<p>open方法只是初始化，并不会发送请求，注意AJAX只能是<code>同源</code>的，如果跨域的话，是会报错滴。</p>

<h3>send方法</h3>

<p>接受一个参数，是作为请求主体发送的数据，如果不需要传入数据，就得传入null。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span><span class="o">:</span>
</code></pre></div>
<h3>响应的结果</h3>

<p>响应数据自动填充XHR对象的属性，包括：</p>

<ul>
<li>responseText：作为响应主体被返回的文本</li>
<li>responseXML：如果是&#39;text/xml&#39;或者是&#39;application/xml&#39;，就会包含XML DOM文档</li>
<li>status：可以将status状态码等于200作为成功的标志，304代表可以从缓存拿，也是正确的</li>
<li>statusText：HTTP状态的说明</li>
</ul>

<p>注意204状态码可能会有问题</p>

<h3>异步的监听</h3>

<p>就是在<code>open方法调用之前</code>，重写下onreadystatechange。
<code>javascript
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
    //这里的状态有4种，一般4代表完成了
    }
};
</code></p>

<p>在接收到响应之前还可以调用abort方法来取消异步请求。取消之后，还得对XHR对象进行解引用的操作</p>

<h2>HTTP头部信息</h2>

<p>我们可以在open方法之后，send方法之前调用<code>setRequestHeader</code>方法来设置成自己想要的值。</p>

<p><code>getResponseHeader</code>方法可以得到对应的值，加个<code>s</code>就可以得到所有的头部信息。</p>

<h2>GET 请求</h2>

<p>get请求的情况最多，一般就是将查询字符串参数追加到URL末尾。</p>

<p>最容易发生的错误是未将名称和值通过encodeURIComponent方法来转码。</p>

<p>注意所有的名值对都必须使用<code>&amp;</code>分隔才行。</p>

<h2>POST 请求</h2>

<p>想支持POST的数据，就得模拟form表单
在open方法之后</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">&#39;Content-type&#39;</span><span class="p">,</span><span class="s1">&#39;application/x-www-form-urlencoded&#39;</span><span class="p">);</span>
</code></pre></div>
<p>原来post和get方式传输的数据其实是一样的，也是一个&amp;分隔的string！！！</p>

<h1>XMLHttpRequest 2级</h1>

<p>2级并没有得到全部的支持</p>

<h2>FormData</h2>

<p>可以帮助你来将数据数据序列化，这些东西jquery帮我们做的太无感了
<code>javascript
var data = new FormData();
data.append(&#39;name&#39;,&#39;Nicholas&#39;);
</code></p>

<h2>超时设定</h2>

<p>这个东西只有IE8支持，jquery啥的都是用的自己的timeout</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">ontimeout</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){...}</span>
</code></pre></div>
<h2>overrideMimeType方法</h2>

<p>用这个方法可以强行改写服务器端返回的数据的解析方式，这个方法必须在send之前调用。这个方法略不讲道理啊，和服务端好好商量下不行吗。。。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">overrideMimeType</span><span class="p">(</span><span class="s1">&#39;text/xml&#39;</span><span class="p">);</span>
</code></pre></div>
<h2>进度事件</h2>

<p>主要就是下面的6个状态事件</p>

<p>load可以用来替代readystatechange事件，但是实现不太一致</p>

<h3>progress事件</h3>

<p>这个主要是可以监测xhr得到的数值的进度~~这个有些屌啊，这个东西得在open方法之前调用</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">onprogress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">lengthComputable</span><span class="c1">//得到进度信息是否可用</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">position</span><span class="c1">//当前的位置</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">totalsize</span><span class="c1">//总共的预期的数据</span>
<span class="p">}</span>
</code></pre></div>
<h1>跨源资源共享</h1>

<h2>CORS(cross origin resource sharing)</h2>

<p>定义了在必须访问跨源资源时，浏览器和服务器如何沟通。</p>

<p>思想是使用自定义的HTTP头部来决定请求或者响应是否成功。</p>

<p>在发起请求时带一个Origin:http://www.baidu.com</p>

<p>然后在后端返回的时候给一个Access-Control-Allow-Origin，里面可以是‘*’或者一个特定的网址。</p>

<p>如果没有或者不符合的话，浏览器就会驳回请求。</p>

<p>这里IE是推出了一个XDR对象，和XHR很类似。</p>

<p>而其他的浏览器则是在原生的XHR上做了实现。</p>

<h2>图像Ping</h2>

<p>使用图像来发送请求是最简单的单项通信了,这个东西最适合来做监控或者说是打点了。因为无法得到服务器端的数据，只能发送GET请求</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
<span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s1">&#39;http://www.example.com/test?name=Nicholas&#39;</span><span class="p">;</span>
</code></pre></div>
<h2>JSONP</h2>

<p>JSONP是通过动态加载一段js来做到的，就是先声明了一个function，插入到body中。</p>

<p>把function的name交给后端，后端返回一段方法的调用，并且传入参数。</p>

<p>浏览器接收到的实际上就是script，会直接调用那个申明好的方法。</p>

<h2>Comet</h2>

<p>这个有长轮询和短轮询和流</p>

<h3>短轮询</h3>

<p>浏览器定时向服务器发送请求，然后不停地刷</p>

<h3>长轮询</h3>

<p>浏览器向服务器发送请求，服务器保持链接的打开，等到有数据传送的时候发送数据。</p>

<p>浏览器接收好数据之后，再打开一个新的连接。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">轮询的好处在于所有的浏览器都是支持的
</code></pre></div>
<h3>流</h3>

<p>就是说整个的周期只使用一个HTTP请求，然后服务器保持链接打开，然后周期性的发送数据，然后xhr的readyState就会周期性的变成3了。</p>

<p>如果是XHR实现的话，如下：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">results</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">3</span><span class="p">){</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">.</span><span class="nx">subString</span><span class="p">(</span><span class="nx">received</span><span class="p">);</span>
        <span class="nx">received</span> <span class="o">=</span> <span class="nx">reslult</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="c1">//然后处理最新的数据</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span><span class="p">){</span>
        <span class="c1">//处理结束的任务</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3>SSE API</h3>

<p>这个必须得是同源的，并且是个单向的连接，默认情况下，这个会保持与服务器的活动链接，如果断开了还会自动重连。</p>

<p>响应的MIME类型是text/event-stream，是纯文本</p>

<p>我们也可以使用event.close();来强行断开这个连接并且不再重连。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventSource</span><span class="p">(</span><span class="s1">&#39;tesr.php&#39;</span><span class="p">);</span>
<span class="nx">source</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2>Web Socket</h2>

<ul>
<li>在一个单独的持久链接上提供双全工，双向通信。</li>
<li>创建后，会有HTTP请求发送到浏览器，取得服务器响应之后，连接会从http协议变成web sockets协议</li>
<li>协议是自己定的，所以是ws:www.example.com</li>
</ul>

<p>web socket支持情况非常差，但是没有同源策略的限制，连不连接全依靠服务器端来识别。</p>

<p>一旦尝试创建，会有一个readyState表示状态，想要关闭，可以在任何时候调用close方法。</p>

<p>一旦打开了之后，就可以来send任何的数据，但是只能发送纯文本，所以必须先JSON.stringify才行。</p>

<p>一旦受到消息，会触发onmessage方法。</p>

<p>还有一些方法，比如open，eror，close会在相应地时刻触发。</p>

<h2>安全</h2>

<h4>CSRF</h4>

<p>cross-site-request-forery 跨站点请求伪造</p>

<p>注意改变get变成put，检查来源，检查cookie都不行</p>

<p>可以的解决方法：</p>

<ul>
<li>以ssl来访问可以通过XHR请求的资源</li>
<li>每次请求都得到附带响应算法的验证码</li>
</ul>

<p>tudo:跨源资源共享那里还有些问题。
tudo:ssl是啥？</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-52">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
