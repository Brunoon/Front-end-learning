<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/stylesheets/print.css">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
  <link rel="stylesheet" href="/Front-end-learning/css/highlight.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <h1>6章面向对象的程序设计</h1>

<p>重新看一次这一章..</p>

<p>对象就是无序属性的集合，属性包含基本值，对象和函数</p>

<h2>创建简单对象</h2>

<p>我们可以new Object()或者通过对象自变量{}的形式来创建。</p>

<p>每个属性都有一些特性，包括</p>

<ul>
<li>Configurable:能够通过delete删除或者重新定义属性的特性</li>
<li>Enumerable:能否通过for in循环返回属性</li>
<li>Writable:是否可以修改属性的值</li>
<li>Value：属性的数据值</li>
</ul>

<p>一般这些特性都是true的，想要修改的话，我们只能使用<code>Object.defineProperty</code>来进行修改。</p>

<p>有种叫做访问器属性，只能通过defineProperty来进行定义，我们可以定义get和set方法，当然可以不全部指定。</p>

<p>我们还可以通过defineProperties来一次定义多个属性。</p>

<h3>读取属性的特性</h3>

<p>Object.getOwnPropertyDescriptor可以得到想要的属性的特性。</p>

<h2>创建特定形式的对象</h2>

<h3>工厂模式</h3>

<p>最初是工厂模式的，就是简单的一个方法，每次new Object()，然后添加属性，最后返回这个新的对象回去，但是问题来了，我们得不到创建出来的东西的类型，于是有了构造函数的模式</p>

<h3>构造函数</h3>

<p>我们使用构造函数来创建对象，每个对象都能访问到contructor(构造函数)属性，该属性指向构造函数(注意这个constructor并不是实例本身拥有的，而是原型对象会有这个constructor，然后属性查找找到了原型上的contructor而已！！！！！)。</p>

<p>只要创建了一个新函数，就会为该函数创建一个prototype，指向该函数的原型对象。</p>

<p>原型对象会有一个constructor，指向构造函数。</p>

<p>实例对象只拥有一个指针能指向原型对象，一般叫做<strong>proto</strong>，基本都是被隐藏的属性！！如果我们想要遍历原型链的话，可以通过ES6的Object.getPrototypeOf来拿，最后一层为null。</p>

<p>所以</p>

<ul>
<li>只有原型对象才会有contructor！！其他的实例对象能够访问是因为查找了原型！！</li>
<li>只有函数才有prototype！！！实例对象也拥有指针指向原型对象，就是<strong>proto</strong>！！！</li>
</ul>

<p>我们一旦在实例上申明了属性覆盖了原型属性，除非我们使用<code>delete</code>，才能够访问到原型属性。</p>

<p>Object.getOwnPropertyDescriptor只能得到自己对象上属性的描述符，想得到原型对象上的，只能直接在原型对象上调用这个方法。</p>

<p>想要判断属性是不是原型属性：<code>!Object.hasOwnProperty(name) &amp;&amp; (name in object)</code></p>

<p>注意constructr和<strong>proto</strong>规范上也是enumerable为false的，当时并不是所有的浏览器都是这么实现的</p>

<p>Object.keys可以得到for in循环的所有属性，当然不包括enumerable为false的;而Object.getOwnPropertyNames()可以得到所有的实例属性，包括不可枚举的，但是<strong>proto</strong>这种不开放的还是得不到。</p>

<p>高程145页是有问题的，他说实例是有constructor的，其实没有..</p>

<h3>重写原型</h3>

<p>一般情况下我们为原型赋予新的属性，得一次次的敲，也可以直接重新给原型对象赋一个新对象</p>

<p>但是问题是我们新建的对象没有constructor了，我们可以在对象里面手动设置为原构造函数。但是直接设置的话，enumerable就是true了，所以我们可以用<code>Object.defineProperty</code>来创建。</p>

<p>我们哪怕在生成了之后再进行原型对象的属性赋予，也是可以的。毕竟就是一个指针嘛，但是如果重设成一个对象，那么原来的原型还是老的。新的原型就是新设置的。</p>

<p>注意原型对象的this也被绑定到了新对象！！就是输如果原型方法return this，返回的是自身！！</p>

<h3>原型模式的弊端</h3>

<p>原型模式最大的弊端是在共享属性，如果属性是一个函数的话，还不会有什么问题，如果属性不是函数的话，可能会造成相互影响的问题，除非每次new的时候都比较小心一点。</p>

<p>所以基本上构造函数肯定是和原型模式一起使用的。</p>

<p>这里有个什么动态的原型模式，很无聊，就是在构造函数内部进行判断，然后初始化原型...</p>

<p>还有个什么寄生构造函数模式，乱七八糟的，就是用return一个新的对象来替代new出来的新对象，没啥价值...</p>

      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
