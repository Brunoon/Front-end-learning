<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>


    <section class="main-content">

      <h1 id="section">22高级技巧</h1>

<h2 id="section-1">高级函数</h2>

<h3 id="section-2">安全的类型检测</h3>
<p>typeof并不能够满足，有时对正则typeof也会返回function。</p>

<p>instanceof在页面上存在多个全局作用域的时候也是问题多多，比如多个frame，他们就不行了。</p>

<p>JSON对象也有这个问题。</p>

<p>解决方法很单一：</p>

<p>Object.prototype.toString.call(obj)就行了。</p>

<ul>
  <li>数组的就是[object array]</li>
  <li>函数的就是[object function]</li>
  <li>正则表达式就是[object RegExp]</li>
</ul>

<p>如果不是原生的话，任何构造函数都会是[object Object]</p>

<h3 id="section-3">作用域安全的构造函数</h3>
<p>这个很有意思</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">job</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这个方法new的话不会有问题，但是如果直接调用的话，里面的this就会变成window，所以安全的写法应该是进行一次判定。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">job</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">job</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这样子的话在通过构造函数窃取时会出现问题</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Perple</span><span class="p">(</span><span class="nx">d</span><span class="p">){</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="nx">d</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这里在new Perple的话，因为了一层判断，就会返回一个new Person，实际上没用..</p>

<p>所以解决方法是加上Perple.prototype = new Person();</p>

<p>这样instanceof就可以进行判断了。赞~~</p>

<h3 id="section-4">惰性载入函数</h3>
<p>惰性载入表示函数执行的分支仅仅会发生一次，比如一些创建xhr对象，每次都会进行if的一些判断，看是否支持，每次创建的时候都会进行判断，实际上没有必要</p>

<p>两种写法</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="nx">createXHR</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(){</span>
      <span class="nx">createXHR</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){}</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="nx">createXHR</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">createXHR</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre>
</div>

<p>这种写法是在第一次调用的时候就进行替换，最后执行一下，下次的话，就会直接执行新函数了</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code>  <span class="nx">createXHR</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(){</span>
      <span class="k">return</span> <span class="kd">function</span><span class="p">(){}</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kd">function</span><span class="p">(){}</span>
    <span class="p">}</span>
  <span class="p">})();</span>
</code></pre>
</div>

<p>这种写法就是在申明的时候就进行一次判断，这样以后的执行都不再需要判断了。</p>

<h3 id="section-5">函数绑定</h3>
<p>就像是settimeout的函数一般会用一个匿名函数调用一样，因为这里是有函数绑定的问题的。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">User</span><span class="p">(){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">();</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">user</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
<span class="p">},</span><span class="mi">1000</span><span class="p">);</span>
</code></pre>
</div>

<p>这里的问题就是没有保存user.y的环境，所以this对象的指向会错。我们可以使用一个闭包来修正这个问题。所以才会有bind方法这种东西存在。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">arguments</span><span class="p">);</span>    
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这样子就是最简单的bind方法了，注意apply接收的参数只要是arrayLike的就好了，所以我们可以直接将arguments传给他。之所以polyfill使用了一对concat，slice之类的是因为要支持bind传参的功能，就像下面这样。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">oldArgs</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">newArgs</span> <span class="o">=</span> <span class="nx">oldArgs</span><span class="p">.</span><span class="nx">concat</span><span class="p">([].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">));</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">newArgs</span><span class="p">);</span>    
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>但是还要支持new方法呢，就得在其中插入一层原型链，如下：</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">oldArgs</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">Temp</span><span class="p">(){}</span>
  <span class="nx">Temp</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">newFn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">newArgs</span> <span class="o">=</span> <span class="nx">oldArgs</span><span class="p">.</span><span class="nx">concat</span><span class="p">([].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">));</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Temp</span> <span class="p">?</span> <span class="k">this</span> <span class="p">:</span> <span class="nx">obj</span><span class="p">,</span><span class="nx">newArgs</span><span class="p">);</span>    
  <span class="p">}</span>
  <span class="nx">newFn</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Temp</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">newFn</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>注意绑定过的已经无法再次bind了。因为绑定后得到的已经不是原函数了，而是一个处理原来方法的闭包而已。</p>

<h3 id="section-6">函数柯里化</h3>
<p>柯里化一般就是传入要柯里化的函数和必要参数，然后返回一个新的闭包函数来处理下参数。等于就是分次给函数添加参数，最后执行的过程。</p>

<p>调用之后通过传给函数部分参数来得到一个新函数，用来处理接下来的参数，有种预加载的用处。</p>

<p>上面的bind其实我已经做过了柯里化的过程了。</p>

<p>作用：</p>

<ul>
  <li>预加载，动态创建新函数，比如get，post这两种方法的实现都是通过柯里化的形式传一个type，然后动态生成的新函数，因为这两个函数的差异很小。</li>
  <li>延迟执行，累计传入的参数，最后执行。</li>
  <li>通过一个通用的函数来创建出更具体的功能</li>
  <li>那种浏览器能力检测返回新函数的惰性载入函数的机制也是一种柯里化的过程</li>
</ul>

<p>其实柯里化是函数的部分执行，这个其实应该是个静态的方法，与一切外部无关的东西，上面的bind的柯里化才是真实的柯里化。</p>

<h2 id="section-7">防篡改对象</h2>
<p>目前我们可以通过设置属性的configurable，writable，enumerable，value，get，set来改变属性的行为。我们还可以通过ES5的一些方法来让对象无法篡改，但是一旦设置了，就<code class="highlighter-rouge">无法撤销</code>了。</p>

<h3 id="section-8">不可扩展</h3>
<p>Object.preventExtensions可以将对象设置为不可扩展。这个方法IE9才支持，opera压根就没有。用Object.isExtensible来检测。</p>

<p>设置了之后，就无法再改回去了。注意只是新属性不能被添加。原有属性想怎么整怎么整。</p>

<h3 id="section-9">密封的对象</h3>
<p>Object.seal方法可以把对象密封，就是无法扩张的情况下也无法删除。但是原有属性的值是可以修改的。</p>

<p>Object.isSealed方法可以确定对象是否被密封了。注意这个对象也是不可扩展的。</p>

<h3 id="section-10">冻结的对象</h3>
<p>最严格的级别是冻结对象，使用Object.freeze可以冻结。</p>

<p>Object.isFrozen用于检测</p>

<p>tudo://608页的访问器属性仍然是可写的。</p>

<h2 id="section-11">高级定时器</h2>
<p>就是说定时器并不能保证到了时间立即执行，只能说是时间到了，就会添加进队列中</p>

<h3 id="section-12">重复的定时器</h3>
<p>setInterval本身是有些错误的，因为有可能还没执行好，就又被添加进执行序列了，所以一般情况下使用setTimeout来模拟。避免连续运行。</p>

<h3 id="yield-processing">yield processing</h3>
<p>js的能力其实是被浏览器限制的，防止恶意程序猿来让计算机崩溃。所以在一些过分超长的行为发生的时候，我们需要用数据分块的技术。来将数据一小块一小块的进行处理。</p>

<p>就是说我们在有些时候可以通过设置定时器的事情来将一件事情分成很多次的执行，这样子避免了因为js的同步执行问题导致的系统的阻塞，实现如下:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">chunk</span> <span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">process</span><span class="p">,</span> <span class="nx">context</span><span class="p">){</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">item</span>  <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">item</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span><span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>### 函数节流
就是说我们在一些会被不断调用的方法执行时，必须进行调用的处理。例如resize方法被调动的次数会相当频繁，如果涉及到了DOM操作的话，对于浏览器的压力其实非常大的。所以我们可以使用一种节流的方式来做。比如如下：</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">context</span><span class="p">){</span>
  <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">tId</span><span class="p">);</span>
  <span class="nx">fn</span><span class="p">.</span><span class="nx">tId</span>  <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
  <span class="p">},</span><span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这样子就可以在持续触发的时候只执行最后一次的。</p>

<p>还有throttle的写法，都已经深入研究过了，参见我的<a href="https://github.com/panyifei/learning/blob/master/前端基础/throttle和debounce.md">另一篇文章</a></p>

<h3 id="section-13">自定义事件</h3>
<p>自定义事件其实是一种观察者模式。是用来解耦的一个东西。</p>

<p>本来觉得事件系统是个好神秘的东西，那次勐喆一说。原来就是继承了一层原型，然后on其实就是绑定了一个特别的属性而已，emit就是属性的调用。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyEvent</span><span class="p">(){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">handlers</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">MyEvent</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span><span class="p">{</span>
  <span class="na">addHandler</span><span class="p">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">handler</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">fire</span><span class="p">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">name</span><span class="p">]();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这个其实就是个最简单的事件了，但是我们想要让一个东西继承这个事件，不能直接A.prototype = new MyEvent()的。因为这样的话，原型的属性handlers是会被相互影响的。我觉得可以使用借用构造函数。我来看下别人是怎么写的。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">Something</span><span class="p">,</span> <span class="nx">MyEvent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</code></pre>
</div>

<p>别人用的underscore的extends，好吧，等于就是把prototype上的东西复制了过来，因为使用的Events的prototype里面的每个方法都检测了是否拥有handlers，所以没有出问题。我们想使用的话只能用借用构造函数和原型继承一起的形式。这样才能保证原型上的属性被单独地继承了。</p>

<h3 id="section-14">拖放</h3>
<p>这里还稍微解释了拖放的原理，就是鼠标事件的时候重新设置下元素的定位，通过event.cilentX和event.cilentY来进行定位。
tudo:EventUtil是个什么东西？</p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">panyifei</a>.</span>
</footer>


    </section>
    <div id="disqus_thread"></div>
    <script>
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = '//panyifei.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>
  </body>
</html>
