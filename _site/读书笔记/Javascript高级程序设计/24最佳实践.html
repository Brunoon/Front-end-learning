<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <h1>24最佳实践</h1>

<h2>可维护性</h2>

<p>可理解性，直观性，可适应性，可扩展性</p>

<ul>
<li>做好注释</li>
<li>变量初始化时给出他的类型。</li>
</ul>

<h2>松散耦合</h2>

<p>代码要尽量做到解耦。</p>

<p>解耦的关键就是让他们尽量做好自己的事情。分工要明确。</p>

<ul>
<li>js不要直接修改css的样式，用更改类名的形式可以降低耦合。</li>
<li>css里面也最好不要写expression那种东西</li>
<li>应用逻辑与事件处理程序最好也能够解耦(比如将从事件中获取和应用逻辑拆分开)</li>
<li>任何应用层面的程序都应该可以在不触发事件的情况下运行，这才是测试的可能性</li>
</ul>

<h2>编程实践</h2>

<p>不负责创建或者维护某个对象，我们就不能对它们进行修改</p>

<ul>
<li>不要为实例或者原型添加属性和方法</li>
<li>不要重新定义已经存在的方法</li>
<li>避免全局变量</li>
</ul>

<p>例如YUI就是单一的全局变量，是一个命名空间的概念</p>

<ul>
<li>避免与null进行比较</li>
<li>将数据单独抽取出来作为常量，隔离逻辑与数据</li>
</ul>

<h2>性能</h2>

<h3>注意作用域</h3>

<p>减少向上层作用域的查找过程，局部的函数或者变量肯定要比全局的开销要小一些。</p>

<p>避免使用<code>with</code>，因为with会建立自己的作用域链，延长了作用域链，肯定是会影响性能的。</p>

<h3>选择正确的方法</h3>

<h4>时间复杂度上的优化</h4>

<ul>
<li>O(1)：正常的常数和变量值，还有数组元素的访问也是O(1)</li>
<li>O(log n)：二分查找</li>
<li>O(n)：对象的属性获取(因为是个遍历的过程)</li>
<li>O(n2)：每个值都得获取n次，插入排序</li>
</ul>

<p>就是说尽量减少算法的复杂度，多使用局部变量来暂存住，然后如果能够使用数字化的数组位置来访问的话，就尽量用数字位置。</p>

<h4>优化循环</h4>

<ul>
<li>减值迭代：价值不大，感觉浏览器基本帮你做完了</li>
<li>简化终止条件：每次循环都会操作，可以尽量减少O(n)的属性查找</li>
<li>简化循环体：这也是废话了，执行最多的，所以要保证最大限度的优化</li>
<li>使用后测试循环：一般的for和while都是前测试，而如果我们能够保证第一次的值肯定会有一个的话，可以改成后测试循环！！</li>
</ul>

<h4>展开循环</h4>

<p>就是在循环次数确定时，消除掉循环换成多次调用函数往往更快。(原理是消除了建立循环和处理终止条件的额外开销)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//duff装置</span>
<span class="kd">function</span> <span class="nx">duff</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span><span class="nx">callback</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">iterations</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="o">%</span><span class="mi">8</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="k">do</span><span class="p">{</span>
      <span class="nx">callback</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">left</span><span class="p">]);</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">left</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">//--left的值就是操作结束的值</span>
  <span class="p">}</span>
  <span class="k">do</span><span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">i</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">iterations</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>这个已经是一个改良过的duff，最初版本的是通过switch写的，通过不写break来向下执行的。Duff的好处就是在<code>大数据处理</code>的时候减少了每次的判断的逻辑，还是很有意思的~</p>

<p>其实价值不是特别高</p>

<p>发现了个不错的网站，用来测试计算的性能：https://jsperf.com/</p>

<h4>避免双重解释</h4>

<p>比如下面的</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;alert(3)&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">say</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="s1">&#39;alert(4)&#39;</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="s2">&quot;alert(2)&quot;</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div>
<p>这三种写法js都需要新建一个解释器来对字符串进行解析的，开销是很大的，尽量避免吧。</p>

<h4>还有一些小的tip</h4>

<ul>
<li>尽量用原生的方法，主要是Math的，因为这些事c/c++写的，速度更快</li>
<li>switch语句比一般的for的速度要快，而且case语句可以按照最可能到最不可能的顺序来写</li>
<li>位运算符应该会更快一些</li>
</ul>

<h3>最小化语句数</h3>

<ul>
<li>语句数其实也会影响执行的速度，我们在申明的时候可以将他们整合。</li>
<li>迭代值可以使用++的形式来节省语句。</li>
<li>使用数组和对象字面量的形式来书写是能够减少语句的</li>
</ul>

<h3>优化DOM操作</h3>

<ul>
<li>最小化现场更新，就是createDocumentFragment来作为一个占位的，然后都append好了之后一次搞定就行。</li>
<li>比这个更快地，使用<code>innerHtml</code>来改变，因为innerHtml是内部调用了内置的DOM调用，而不是基于JS的DOM调用。</li>
<li>使用事件代理，这个比较常用，就是在祖先节点上绑定来节省绑定次数以及支持动态绑定</li>
<li>合理使用HTMLCollection，因为文档上的查询开销很昂贵，合理使用</li>
</ul>

<h2>部署</h2>

<p>我们的Js代码是没法直接放到线上的，因为注释，长变量名和空白其实都是没有价值的。</p>

<p>一般会进行一次js的验证，比如JSLint。</p>

<p>所以一般会进行压缩，比如YUICompressor，删除空白，注释，缩短变量名。</p>

<p>然后还会有HTTP的压缩，比如GZIP压缩。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Gzip其实是浏览器与http提供的，浏览器在发送request的时候会发一个Accept-Encoding:gzip,deflate之类，然后服务器就会返回按照它支持的压缩过的文本
</code></pre></div>
      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
