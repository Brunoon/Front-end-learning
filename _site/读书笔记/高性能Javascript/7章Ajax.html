<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="UTF-8">
  <title>Front-end-learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">Front-end-learning</h1>
  <h2 class="project-tagline">一个前端工程狮的打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>


    <section class="main-content">

      <h1 id="ajax">7章Ajax</h1>
<p>Ajax从最基本层面说，是一种与服务器建立通信而无需重载页面的方法，数据可以从服务器获取或发送给服务器。有很多种方法建立通信，各有各自的优点和限制。</p>

<h2 id="section">请求数据的方式</h2>
<ul>
  <li>XMLHttpRequest</li>
  <li>动态脚本注入</li>
  <li>iframes</li>
  <li>Comet</li>
  <li>Multipart XHR</li>
</ul>

<p>Comet和iframes作为数据传输技术往往用在极端情况下，这里就不讨论了。</p>

<p>XHR其实也什么好说的，毕竟现在的使用范围那么广，尽管是同域限制。注意post和get的区别，当我们经常请求某一个数据的时候，可以使用GET，因为get的请求会被缓存。当我们参数较长的时候，我们应该用Post来获得数据，因为IE限制URL长度，过长时会导致请求的URL被截断。</p>

<p>动态脚本注入的话，实际上就是JSONP，解决跨域的较好的方法。但是只能使用get请求，并不能使用post，关于跨域的问题我会重新整理一遍。</p>

<p>MXHR其实和XHR非常类似，也是同样的请求，不过是将一些静态资源在后端进行base64位的编码，然后通过一个请求传到前端，然后我们可以在readyState等于3的时候看下传到的资源，不过这件事情的价值不大..首先是我们可以直接base64放在文档里面，其次每个图片的base64里面都有一些部分是申明的会被浪费，雪碧图说不定效果还更好一些，而且最大的问题，这些资源不能被浏览器缓存。</p>

<h2 id="section-1">发送数据</h2>
<p>我们通过get和post方法都是可以发送数据，GET会更快一些，一个GET请求只发送一个数据包，而一个POST请求，至少要发送两个数据包(一个装载头信息，一个装POST正文。POST更适合发送大量数据，他不关心额外数据包的数量。另一个原因是IE对于URL长度有限制，GET会被限制。</p>

<p>Beacons</p>

<p>这个技术我们非常类似于动态脚本注入，就是通过设置<code class="highlighter-rouge">img的src</code>来发送请求(而且并不用创建img元素或者将它插入DOM中，只需要new Image()就行了)。我们只能监听onload事件来看请求是否成功，或者监听this.width来根据服务器返回的图片的宽度来得到响应。其实这个东西使用过，用来监听一些网络状况比较好使，打点嘛</p>

<h2 id="section-2">数据格式</h2>
<p>### XML
AJAX最开始的时候，使用的是XML作为格式，因为通用性极佳，操作严格，易于验证</p>

<p>但是xml太冗余，有效数据比例很低，而且限制于结构，我们需要针对每段XML写不同的解析的工具，很麻烦。我们可能得使用getElementByTagName</p>

<p>但是现在高级点的浏览器都有xPath来通过一个路径来获取值，但是低级的浏览器不支持，IE8有类似的，就算用也得使用getElementByTagName来写降级的代码。</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">path</span><span class="o">=</span><span class="s2">"/bookstore/book/title"</span><span class="p">;</span>
<span class="nx">xml</span><span class="p">.</span><span class="nx">selectNodes</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="json">JSON</h3>
<p>JSON是一种使用Javascript对象和数组直接量编写的轻量级且易于解析的数据格式。我们解析JSON很简单，只要JSON.parse和JSON.stringify就可以。</p>

<p>支持性还可以，正常的浏览器都可以，IE8以及以上是支持的。不支持的话，我们可以有简单的polyfill。</p>

<p>parse方法最简单的polyfill就是用eval执行一遍直接就能转化为对象了。</p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">Front-end-learning</a> is maintained by <a href="https://github.com/panyifei">panyifei</a>.</span>
</footer>


    </section>
    <div id="disqus_thread"></div>
    <script>
      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = '//panyifei.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>
  </body>
</html>
