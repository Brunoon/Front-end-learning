<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="UTF-8">
  <title>前端技术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/Front-end-learning/stylesheets/print.css">
  <link rel="stylesheet" href="/Front-end-learning/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/Front-end-learning/css/cayman.css">
  <link rel="stylesheet" href="/Front-end-learning/css/font-awesome.min.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">前端技术</h1>
  <h2 class="project-tagline">逸飞的前端打怪日常，主要是javascript</h2>
  <a href="https://github.com/panyifei/Front-end-learning" class="btn">View on GitHub</a>
  <a href="https://github.com/panyifei/Front-end-learning/archive/master.zip" class="btn">Download .zip</a>
  <!-- <a href="#" class="btn">Download .tar.gz</a> -->
</section>

    <section class="main-content">
      <h2>前端基础知识</h2>

<h3>基本数据类型以及typeof的结果</h3>

<p>基本数据类型：</p>

<p>null，undefined，string，boolean，number，还有一种复杂的object</p>

<p>typeof的结果：</p>

<p>undefined，number，string，boolean，object，function</p>

<h3>querySelectorAll和getElementByClassName的区别</h3>

<p>querySelectorAll是没有性能问题的，因为它不是动态的</p>

<p>getElementByClassName是有性能问题的，他会动态刷新</p>

<h3>闭包</h3>

<p>就是在函数的最后返回一个函数回去，返回的函数拥有访问原函数内部变量以及参数的能力，如果不手动设置为null的话，垃圾回收器是无法回收的。</p>

<p>他的价值在于可以用来生成模块模式，搞出一个只有返回的闭包本身才能访问到的私有变量和函数。</p>

<h3>阻止冒泡和默认事件</h3>

<p>冒泡：e.stopPropagation,IE下位cancelBubble=true，</p>

<p>默认事件，e.preventDefault(),e.returnValue=false,return false(用来取消对象属性注册的处理程序)</p>

<h3>addEventListener的第三个参数</h3>

<p>只有在有父元素，并且有同样类型的处理事件时才有用，默认为false，默认为bubble，从内向外，设置为true后，就从外向内触发了。</p>

<h3>类型检测</h3>

<p>其实就是typeof嘛，最简单的类型检测</p>

<p>还有就是instanceof,这个三目运算符是用来看是否在原型链上</p>

<p>但是对于多全局对象，内置的全局构造函数是不同的，所以instanceof会有问题，使用Array.isArray倒是可以，不过这东西ie9才支持，所以两种：</p>

<ul>
<li>Object.prototype.toString.call([]) == [object array]</li>
<li>先typeof [].length == &#39;number&#39;然后[].propertyIsEnumable(&#39;length&#39;)==fasle，因为array的length属性是不可枚举的</li>
</ul>

<h3>继承</h3>

<p>到现在写个继承居然自己写错了！！！唉..</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">A</span><span class="p">(){}</span>
<span class="kd">function</span> <span class="nx">B</span><span class="p">(){}</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
</code></pre></div>
<p>这是最简单的</p>

<p>最简单的原型继承就是上面的，但是这样父原型的实例属性变成原型属性，且无法传参数</p>

<p>所以可以借用构造函数继承，就是在子类中调用父类型的构造函数，但是没有原型关系，父类的原型方法子类继承不到</p>

<p>所以混合着用的一般比较比较多</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Super</span><span class="p">(){</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Sub</span><span class="p">(){</span>
  <span class="nx">Super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Sub</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Super</span><span class="p">();</span>
</code></pre></div>
<h3>Polyfill温习一下</h3>

<p>就是感觉涨了见识吧，比如用x-qsa，expresssion的css属性来抓取元素模仿querySelectorAll方法，还有defineProperty这个东西实际上调用了<strong>defineGetter</strong>等，还有bind方法，一般直接写个this.apply(obj,[].slice.call(arguments)),为了让bind方法支持new，还在里面写了一个原型继承。</p>

<h3>shrinkwrap怎么管理项目依赖的</h3>

<p>因为很有可能第三方的没有按照规范来定义版本号，npm shinkwrap可以根据当前的package.json中稳定的版本进行构建一个文件，写死了版本，以后npm install的时候，拿取的就是老版本的了</p>

<h2>克隆一个对象</h2>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">newObj</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">){</span>
    <span class="nx">newObj</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">){</span>
      <span class="nx">newObj</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">){</span>
    <span class="nx">newObj</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">){</span>
      <span class="nx">newObj</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>      
    <span class="p">}</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="nx">newObj</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2>AMD和CMD规范</h2>

<p>AMD依赖前置，所以异步并行加载</p>

<p>CMD按需依赖，所以还是顺序加载</p>

<p>node端是Commonjs</p>

<h2>前端安全</h2>

<p>永远不相信前端输入，1个是前端的验证要通过正则啊等等的验证，后端也必须得再校验一遍</p>

<h3>XSS攻击</h3>

<p>就是在网页上插入html标签或者javascript代码。</p>

<p>解决：
  - 针对提交的结果后端设置一层filter,对&lt;&gt;进行过滤
  - 东西写到页面上的时候都进行一次encode，放置将html标签显示出来
  - 不在cookie里面存重要的信息</p>

<h3>CSRF(跨站点请求伪造)</h3>

<ul>
<li>传一个token</li>
<li>判断来源referer</li>
</ul>

<h3>机器人的攻击</h3>

<p>进行验证码的验证</p>

<p>两者的区别在于XSS是访问，不需要什么数据，CSRF是一次动作，是需要一些数据包的</p>

<h2>manifest</h2>

<p>就是在html元素里定义了这个属性，就可以进行缓存了，当做离线应用进行缓存</p>

<h2>web worker</h2>

<p>运营在后台的js，独立于页面，可以不阻塞主线程</p>

<h2>BFC</h2>

<p>块级格式化上下文，是一个独立的布局环境，其中的元素布局不受外部的影响。
float不是none，position是absolute或者fixed，或者overflow不是visible，display的值是inline-block，flex，table-cell等等</p>

<p>他的作用：
避免外边距折叠，在外面加上一层BFC
也能触发包含了浮动元素，内部不被撑开的情况
避免文字环绕</p>

<h2>点击穿透</h2>

<p>就是点击之后上层DOM改变，下层中同样位置的元素触发点击事件，就是点击穿透。</p>

<p>一般就是touchstart--touchmove--touchend，然后touchend之后浏览器会延迟300ms来监听是否触发了dbclick事件。</p>

<p>tudo：如何解决？？</p>

<h2>如果构造函数里有return语句</h2>

<p>如果构造函数return的不是引用类型，那么就会当没有return；</p>

<p>如果返回的是引用类型，那就会替换掉返回的东西；</p>

<p>如果是return this，那么当做构造函数调用的话等于就是没有写。</p>

<h2>==和===的区别</h2>

<p>tudo：</p>

<h2>HTTPS的好处</h2>

<p>全站HTTPS：
主要为了摆脱运营商的劫持</p>

<p>因为发一个http请求，属于明文传输，中间代理服务器，路由器，网关出口，通信运营商，都可以劫持到请求，就可以拿到放在url里的一些参数，cookie也可以拿到，返回的内容，他也可以添加一些第三方的内容</p>

<p>HTTPs就是进行了数据的保密，数据的完整，身份的校验，就是http+ssl，发了请求，会先302到https服务，然后生成一个crt，然后客户端进行验证，然后生成一个随机的加密形式发回后端，后端将加密内容发回来，客户端再进行解密进行展示。</p>

<p>主要问题是请求的响应速度影响明显还有cpu的计算能力的消耗，主要是私钥解密阶段，因为非对称私钥计算很需要时间，而且每次生成的都不一样，而且一定程度上也不利于SEO</p>

<p>只听说过会话复用</p>

<h2>交换两个值，不用额外临时变量</h2>

<p>就三种方法咯，异或的最快</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">456</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span><span class="c1">//加法</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">;</span><span class="c1">//除法</span>
<span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>
<span class="nx">b</span> <span class="o">^=</span> <span class="nx">a</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span><span class="c1">//异或是位操作，速度肯定是最快的啦，相同为1，不同为0，因为异或的反操作还是本身</span>
</code></pre></div>
      <div id="disqus_thread"></div>
<script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//panyifei.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="//panyifei.disqus.com/count.js" async></script>

      <!-- <footer class="site-footer">
  <span class="site-footer-owner"><a href="">前端技术</a> is maintained by <a href="https://github.com/panyifei">逸飞</a>.</span>
</footer> -->

<footer>
	<div class="span-inline">
		
			<span>
				<a target="_blank" href="https://github.com/panyifei">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa fa-github fa-stack-1x fa-inverse"></i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="https://www.zhihu.com/people/pan-yi-fei-41">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">知</i>
					</span>
				</a>
			</span>
		
		
			<span>
				<a target="_blank" href="http://www.jianshu.com/users/3b9067fb7edf">
					<span class="fa-stack fa-lg">
						<i class="fa fa-circle fa-stack-2x"></i>
						<i class="fa  fa-stack-1x fa-inverse">简</i>
					</span>
				</a>
			</span>
		
	</div>
	<p class="copyright">
		Copyright &copy; 前端技术 2016
		<br>
		Owned by <a href="https://github.com/panyifei">潘逸飞</a>
	</p>
</footer>

    </section>
  </body>
</html>
