# 正则表达式与方法
JS的正则借鉴的是Perl，通常正则表达式相较于等效的字符串处理有显著的`性能优势`。

## 看个例子
```javascript
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Z-a-z]+)(?::(\d))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
```

一块块的看，`(?:([A-Za-z]+):)?`，这里`?:`代表后面的分组并不捕获(还蛮推荐这么做的，因为捕获会有性能上的缺失)，最后的`?`代表是可选的，0次或者1次。`()`这个代表捕获组。

`(\/{0,3})`这个代表0个到3个`/`。

([0-9.\-A-Z-a-z]+)这个主要是里面的`.`字符，这个字符在外面代表着任意字符，在中括号里面代表着`.`。中括号里面好像就只有`-`需要进行转义。

其他的就比较正常了。

## 标识
  - g：全局，匹配多次，(不同的方法对这个的支持不同，exec代表着下次匹配的位置，search会忽略，match会返回所有的匹配结果..)
  - i：是否区分大小写
  - m：是否支持多行(^和$能匹配航结束符，使用了m之后，正则表达式就会匹配每行的开头和结尾了)

如果我们创建一个正则表达式时使用RegExp的写法的，注意`\`本身需要转义，也就是说我们使用他来转义时，需要使用两个。因为我是通过字符串的形式传入的，而字符串的\在正则和字符串中有特别的含义，所以这个符号我们需要进行转义。

## RegExp对象的属性

 - global：如果标识g被使用，值就是true
 - ignoreCase：如果是i被使用，值为true
 - lastIndex：下一次exec匹配的索引，初始值为0
 - multiline：标识m被使用，值为true
 - source：正则表达式的源码文本

## 正则表达式的一些元素

 - 分支：|，就是只要匹配任意一个条件，就会被匹配
 - 序列：就是包含一个或多个正则表达式因子，每个因子能选择是否跟随一个量词
 - 正则表达式因子：可以是一个字符，一个圆括号的组，一个字符类，或者一个转义序列
 - 转义：其实就是要背一下咯，\d(匹配一个数字),\w(匹配数字字母下划线),\s(空白符)，\1代表分组1所捕获的文本的引用，这个很好使
 - 分组
  - 捕获型：
    - 在圆括号中包住的就是一个捕获组，第一个就是分组1，第二个就是分组2
    - (?<name>exp)：这种写法就是指定了分组名为name了
  - 非捕获型：就是`(?:)`这个仅能做简单的匹配，但是不会捕获所匹配的文本
    - 向前正向匹配：`(?=)`也是非捕获的，即使匹配前面的部分
    - 向前负向匹配：`(?!)?`类似的，但是他是匹配失败才会继续向前进行匹配。
 - 字符集：`[]`就是一组字符的便利方式
 - 转义：就是想匹配特殊字符本身，我们需要加个\来做这件事情
 - 量词：`{}`就是这个因子要被匹配的次数，注意正则遵守贪婪匹配的原则

 
