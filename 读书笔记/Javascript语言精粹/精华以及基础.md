# 精华以及基础
## 优缺点
首先他是弱类型，虽然不会在编辑阶段就能发现一些问题，但是他自由，并且不用应付类型系统来得到想要的行为。

对象字面量表示法：通过列出对象的组成就能被创建，是JSON的灵感来源。

他的原型继承也是争议很大。

主要是他基本都被挂载在全局对象上，共用一个公共命名空间其实是非常大的罪。

## 基础
 - 注释是有两种，一种是/* */的块注释，一种是//，注意块注释可能会有问题，因为在正则中可能会导致块注释提前失效了

 - 注意字符串是不可变的，一旦被创建永远无法被改变，所以只能不断的创建新的字符串。

 - 数字，字符串和布尔值貌似对象，因为他们拥有方法，但是他们是不可变的。`JS中的对象是可变的键控集合！！`

 - 对象的属性名可以是`空字符串`！！但是这些不合法的或者保留字的只能用引号括起来才行。

### 正确的取值
我们一般赋值可以用 || 来设置默认值，用 && 运算符来避免错误，比如：

```javascript
 var a = a.b || "";
 var s = s.aa && s.aa.b;//这样即便aa是undefined也不会报错了
```

 - 对象是通过引用来传递的，所以他们永远不会自动被复制。

### 原型
这里的Object.create的写法其实很简单

```javascript
Object.create = function(o){
     var F = function(){}
     F.prototype = o;
     return new F();
}
```

我们可以通过hasOwnProperty来检测对象独有的属性。

### 函数
创建一个函数的时候，其实会附加两个隐藏属性，一个是上下文，一个是实现函数行为的代码。

调用函数的时候，可以理解为调用函数的"调用"属性。

### this指针
有四种调用方法的模式

### 方法调用模式

就是说函数作为对象的一个属性，那么我们称之为一个方法。如果我们的表达式包含一个提取属性的动作，比如点操作，就被当做一个方法调用。这里毫无疑问，this代表了调用的那个对象。

### 函数调用模式

函数并非是一个对象的属性来调用的时候，就是当做一个函数来调用的，此时的this就是全局对象。浏览器下面是window

```javascript
 var aa = {
        b:function(){
 console.log(this);
        }
 }
 aa.b();//{}
 var c = aa.b;
 c();//window
 (aa.b)();//{}
//当然，这里的执行顺序没有变化，因为.的级别只低于圆括号，高于函数调用。
   //tudo：为什么这里还是一个object？？？
```

### 构造器调用模式
我们使用new来通过构造器调用模式的时候，里面的this是新对象。同时，原型对象上的this也是新对象！！！//tudo

```javascript
 function aa(){
   this.status=1;
 }
 aa.prototype.status = 2;
 aa.prototype.getStatus = function(){
   console.log(this.status)
 }
 new aa().getStatus()//1
```

### Apply调用模式
就是简单的改变this
```javascript
  function add(a,b,c){
    return a+b+c;
  }
  var a=[1,2,3]
  add.apply(null,a);//6
```

### 探讨下bind
当我们用bind方法绑定了this之后，再赋值给一个变量。作为上面的函数调用的结果的this指针指向哪里？

答案是指向bind过的对象。//tudo

### 函数的参数
我们可以通过arguments来访问函数的所有参数，但是arguments并不是一个真的数组，他只是一个“类似数组”的对象，拥有一个length属性，但没有任何数组的方法。当然我们可以使用Array.prototype.reverse.call来调用。

### 递归
这里的递归算法得抽空好好看一看。//tudo

### 作用域
JS没有块级作用域，但是它有函数作用域。ES6的let申明实现了块级作用域。

### 闭包
我们在调用了某个函数的时候，他返回的值也是一个子函数，这个子函数就拥有了访问原函数的变量的能力，这就是闭包。
