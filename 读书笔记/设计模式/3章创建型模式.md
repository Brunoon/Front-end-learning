---
layout: default
title: {{ site.name }}
---
# 3章创建型模式
创建型模式抽象了实例化过程。帮助系统独立于如何创建，组合和表示他的那些个对象。类创建模式使用继承改变被实例化的类。而对象创建型模式将实例化的操作托付给另一个对象。

随着系统演化得越来越依赖于对象符合而不是类继承。系统使用那些具体的类被封装了。隐藏了这些类的实例是如何被创建和放在一起的。创建型模式什么时候被创建，谁创建，以及怎样被创建都是有自主性的。

有时创建型模式是相互竞争的，也有时候他们是可以互补的。

书里先是举了个创建一个迷宫的例子，就是调用了构造方法。然后使用它的实例来进行各种东西的初始化。

虽然我们可以在构造函数中来提前初始化每一面。(这个目前我认为已经解决了问题了...)但是这样仅仅是把代码移到了别的地方，这样子代码会更小，但是设计没有更灵活。我们一旦改变了布局就得重新写一个构造函数。

 - 一种是调用虚函数而不是构造器来创建。我们就可以创建子类并且重定义虚函数。从而改变被例化的类。这是Factory Method模式的一个例子。
 - 通过传入对象来作为参数，可以通过传入不同的参数来改变房间，墙壁和门的类，这是抽象工厂的模式
 - 通过传递一个对象，这个对象可以在迷宫中增加或者减少门房间，墙壁和门。这就是建造者模式的一个例子。
 - 如果由多种原型的房间，墙壁和门对象参数化，可以用不同的对象替换这些原型对象以改变迷宫的构成。这就是Prototype的例子。
 - Singleton保证了每个游戏只有一个迷宫且所有的游戏对象都可以迅速访问它。

 ## 抽象工厂模式--对象创建型模式
 意图：提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。产品种类是固定的，产品系列可以被替换~想增加产品种类会比较麻烦，因为所有工厂都必须改。

 就是定义了一个抽象类，这个类定义了一些接口，然后每种想创建的都是具体的子类来实现具体的功能，然后用户们完全根据`抽象类提供的接口`来使用。客户完全不知道他们使用的是哪些具体类。

适用性：

 - 一个系统要独立于他的产品的创建，组合和表示的时候
 - 系统要由多个产品系列的一个来配置
 - 强调一系列产品对象的设计以便联合使用
 - 提供一个产品类库，只想显示他们的接口而不是他们的实现时

优缺点：

 - 分离了具体的类：将客户与类的实现分离，客户通过他们的抽象接口操纵实例。
 - 使得易于交换产品系列：具体工厂只在初始化的时候，于是我们可以很方便的改变应用的具体工厂
 - 有利于产品的一致性：当系列中产品对象被设计成一起工作的时候，他能保证一次只能使用同一个系列的对象
 - 不能支持新种类的产品：就是抽象工厂如果被扩展的话，会影响到所有的实现。

我们使用工厂的时候，可以通过传递一个参数来指示要创建的对象的种类的参数。

## BUILDER(生成器)--对象创建型模式
意图：将一个复杂对象的构建和他的表示分离，使同样的构建过程可以创建不同的表示。不变的是构建步骤，构建的具体操作可以被多种替换~

就是用户使用一个director来根据一定的步骤来调用builder的创建方法，然后用户从builder那里得到最后生成的东西。(之所以不从director拿是因为director里面不知道生产的是什么产品，只有builder和用户才知道产品是什么)  

适用性：

 - 当创建复杂对象的算法应该独立于对象的组成方式以及装配方式
 - 构造过程必须允许被构造的对象有不同的表示时

效果：

 - 可以改变一个产品的内部表示：因为提供给导向器的是一个抽象接口，所以产品的表示和内在结构其实是被隐藏的
 - 将构造代码和表示代码分开：就是代码拆离开了，用户可以使用不同的director来在相同构件的基础上构做不同的product
 - 可以使得构造过程更精细的控制：因为是在导向者的控制下进行合成，所以builder的接口会很好的反映产品的构造过程

这里说抽象工厂和建造者模式的区别是：builder是一步步构造复杂对象，抽象工厂着重于多个系列的产品对象，抽象工厂直接拿到产品，builder最后拿到。

## 工厂方法--对象创建型模式
意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到他的子类。选择使用哪个工厂的事情交给了使用者。每一个新的产品都得新增一个工厂。
