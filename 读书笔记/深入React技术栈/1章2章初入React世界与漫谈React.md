---
layout: default
title: {{ site.name }}
---
# 1章初入React世界
引入JSX语法，组件复用简单，而且使得代码和真实渲染目标分隔开来，所以可以渲染到浏览器DOM来开发网页，也可以开发原生应用。

React专注于view层的开发，并没有提供很多API，让你根据你的项目来选择配合什么样的框架使用。

虚拟DOM batch了DOM操作，而且他比真实DOM轻量的多，他少了很多历史属性，他还可以用虚拟DOM这一层去对接各大平台。

函数式编程与命令式编程相对应，就是规则的可复用，函数式编程是React的精髓。

## jsx语法
静态编译其实并不是个新鲜事物，之前的CoffeeScript风声水起，但是随着ES6的推进，渐渐销声匿迹，对于react，我们又需要玩转新的静态编译语言。

jsx跟我们的HTML标签很像，所以很容易学，而且让我们可以很形象的描述结构。

我们写jsx的时候记住，定义标签时，只允许被一个标签包裹，而且标签一定要闭合。

如果要加注释的话，如果是在子组件位置，要加上{ /* */ }，如果是在属性位置，那就要去掉{}哦~~

jsx写属性值得时候，如果是布尔值，省略了值的话，jsx默认是true~~

## 组件
其实和web components很像，这里介绍了3种react 组件的实现方式，react.createClass，class和无状态组件。无状态组件的好处是他在创建时都是一个实例，避免了不必要的检查和内存分配，做了内部优化。

## 数据流
react其实并不依赖于外界来做数据流，他是可以管理自己的内部状态的，就是state。他的数据流向从上到下，让组件之间的关系简单并且可预测。setState这个异步操作在一个生命周期结束的时候都会合并起来。虽然state这个能力很强，但是项目中最好少用state，过多的内部数据会然数据流混乱。

## prop
我们可以将一个组件作为属性传下去，然后在组件内通过拿取属性拿到别的组件。我们还可以通过this.props.children来拿取定义的子组件。之前都没有这么用过，为啥？

## 生命周期
我们在componentWillUnmount的时候别忘了事件回收或者清除定时器。componentWillMount可以setState，不过放在constructor里面比较合适。

## react与DOM
为了让react在多个平台被调用，react-dom被单独拆了出来，他提供的API很少。只有findDOMNode，unmountComponentAtNode和render。render平常用的比较多，没啥意思了。findDOMNode是在页面render之后来找到那个真实的DOM元素。ReactDOM.findDOMNode(this)来拿到。而unmountComponentAtNode是用来卸载的。

## ref
ref就是创建的时候一个引用，指向那个创建的实例，上面那个写法是通过this拿指向自己的实例，而通过配置了ref的，this.refs可以拿到子组件的引用。拿取dom来操作并不推荐，不过真的需要的时候，比如一些popup点击空白处收起的时候，是挺好用的，别忘了解绑就好了。

# 2章 漫谈React
## 事件系统
React自己生成了一个合成事件层。他并没有把事件绑到真实节点上，而是把所有事件绑到了结构的最外层，维持一个映射，然后事件发生时，在映射中找到真正的事件处理函数并调用，简化了事件处理和回收机制，效率提升很大。

除了事件委派之外，他还做了自动绑定的事情，就是React.createClass会自动绑定this，但是ES6 classes和纯函数并不会做这件事，得手动绑定或者接入babel的一些插件来做这件事情。还有种就是stage-0的写法了，双冒号来做。

注意如果有时你自己在didMount之后绑定了事件要注意对事件进行解绑，否则可能会造成内存泄漏，如果是react自己的合成事件，就不需要。

看到了一个好神奇的坑，就是尽量不要react与浏览器的事件系统混用，比如react中的阻止冒泡只能阻止react的事件冒泡，并不会阻止原生事件的冒泡，但是原生事件中阻止冒泡，却可以阻止react的事件的传播。react的事件系统只是一个子集，他只实现了部分事件，并且统一了兼容性，还是有不少事件不行的，比如window的resize事件。对于无法使用的，我们需要原声事件来完成。
