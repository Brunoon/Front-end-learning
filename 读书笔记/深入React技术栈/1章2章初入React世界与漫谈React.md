---
layout: default
title: {{ site.name }}
---
# 1章初入React世界
引入JSX语法，组件复用简单，而且使得代码和真实渲染目标分隔开来，所以可以渲染到浏览器DOM来开发网页，也可以开发原生应用。

React专注于view层的开发，并没有提供很多API，让你根据你的项目来选择配合什么样的框架使用。

虚拟DOM batch了DOM操作，而且他比真实DOM轻量的多，他少了很多历史属性，他还可以用虚拟DOM这一层去对接各大平台。

函数式编程与命令式编程相对应，就是规则的可复用，函数式编程是React的精髓。

## jsx语法
静态编译其实并不是个新鲜事物，之前的CoffeeScript风声水起，但是随着ES6的推进，渐渐销声匿迹，对于react，我们又需要玩转新的静态编译语言。

jsx跟我们的HTML标签很像，所以很容易学，而且让我们可以很形象的描述结构。

我们写jsx的时候记住，定义标签时，只允许被一个标签包裹，而且标签一定要闭合。

如果要加注释的话，如果是在子组件位置，要加上{ /* */ }，如果是在属性位置，那就要去掉{}哦~~

jsx写属性值得时候，如果是布尔值，省略了值的话，jsx默认是true~~

## 组件
其实和web components很像，这里介绍了3种react 组件的实现方式，react.createClass，class和无状态组件。无状态组件的好处是他在创建时都是一个实例，避免了不必要的检查和内存分配，做了内部优化。

## 数据流
react其实并不依赖于外界来做数据流，他是可以管理自己的内部状态的，就是state。他的数据流向从上到下，让组件之间的关系简单并且可预测。setState这个异步操作在一个生命周期结束的时候都会合并起来。虽然state这个能力很强，但是项目中最好少用state，过多的内部数据会然数据流混乱。

## prop
我们可以将一个组件作为属性传下去，然后在组件内通过拿取属性拿到别的组件。我们还可以通过this.props.children来拿取定义的子组件。之前都没有这么用过，为啥？

## 生命周期
我们在componentWillUnmount的时候别忘了事件回收或者清除定时器。componentWillMount可以setState，不过放在constructor里面比较合适。

## react与DOM
为了让react在多个平台被调用，react-dom被单独拆了出来，他提供的API很少。只有findDOMNode，unmountComponentAtNode和render。render平常用的比较多，没啥意思了。findDOMNode是在页面render之后来找到那个真实的DOM元素。ReactDOM.findDOMNode(this)来拿到。而unmountComponentAtNode是用来卸载的。

## ref
ref就是创建的时候一个引用，指向那个创建的实例，上面那个写法是通过this拿指向自己的实例，而通过配置了ref的，this.refs可以拿到子组件的引用。拿取dom来操作并不推荐，不过真的需要的时候，比如一些popup点击空白处收起的时候，是挺好用的，别忘了解绑就好了。

# 2章 漫谈React
## 事件系统
React自己生成了一个合成事件层。他并没有把事件绑到真实节点上，而是把所有事件绑到了结构的最外层，维持一个映射，然后事件发生时，在映射中找到真正的事件处理函数并调用，简化了事件处理和回收机制，效率提升很大。

除了事件委派之外，他还做了自动绑定的事情，就是React.createClass会自动绑定this，但是ES6 classes和纯函数并不会做这件事，得手动绑定或者接入babel的一些插件来做这件事情。还有种就是stage-0的写法了，双冒号来做。

注意如果有时你自己在didMount之后绑定了事件要注意对事件进行解绑，否则可能会造成内存泄漏，如果是react自己的合成事件，就不需要。

看到了一个好神奇的坑，就是尽量不要react与浏览器的事件系统混用，比如react中的阻止冒泡只能阻止react的事件冒泡，并不会阻止原生事件的冒泡，但是原生事件中阻止冒泡，却可以阻止react的事件的传播。react的事件系统只是一个子集，他只实现了部分事件，并且统一了兼容性，还是有不少事件不行的，比如window的resize事件。对于无法使用的，我们需要原生事件来完成。

## 表单
react做了一些统一的事情，比如input和textarea，他把textarea的值也做成了value，而不是children了。

在react中，数据是单向流动的，表单数据源于props，然后我们将数据再写回state中，就完成了数据的双绑，其实就是个语法糖，没多大水平。

react中大部分是受控组件，但也支持不受控组件，我们可以用refs直接去取。

## 样式
在react组件的时候，建议实现className，这样可以让用户自定义样式。在style的时候，会默认加上单位px。

## css modules
这里应该是挺好玩的，不过痛点不明显，还好，先略过好了

## 组件间通信
父级向子级就是通过传值呗，自己向父级其实就是会调，通过调用父级传下来的方法。跨多级组件通信我们可以使用context，在高层组件中申明context，然后在下面的层级的组件就都可以访问到了。不过不推荐使用，毕竟无法追溯源头。

没有嵌套关系的组件通信，就通过全局的事件系统来处理，不过这种方式很烂。没什么意思。

## 组件间抽象
之前有mixin这种用法，但是mixin问题比较大，mixin多了不好维护，命名冲突的问题也有可能，增加了复杂度，因为mixin是会叠加生命周期方法的，这个太强大，所以太难用了。

### 高阶组件
高阶组件叼啊

```javascript
const Mycontainer = (A) =>
  class extends Component {
    render (){
      return <A />
    }
  }
```

我们可以在高阶组件上把会变化的东西抽成state，然后全部传props给组件，这样组件就变成stateless了！

mixin和高阶组件的区别在于，mixin的能力是强行插入进来的，而高阶组件是符合函数式编程的，只要把功能套在原组件就行了。我擦，感觉高阶组件更适合来做decorator的事情啊~~好吧，高阶组件其实可以用decorator的语法糖~

高阶组件的反向继承可以控制原组件的渲染，还不错呢~

总结就是我们可以使用大量的高阶函数来将功能抽离，很多可以就是单纯的逻辑组件~~

### 组件性能优化
react官方提供了PureRender这种方式。

其实就是纯函数：相同输入，相同结果；过程没有副作用，没有额外的状态依赖

其实我们现在继承的PureComponent就是Pure渲染。

比如我们设置style的时候如果传入{{color: 'black'}}则每次都是新对象，同样的，在props中为对象或者数据计算新值都会导致PureRender失效。

还有就是我们写在组件上的bind或者调用，其实每次渲染都会执行一遍，这就是多余的，如果需要传参数，怎么办呢？

### immutable
这个实现其实蛮神奇的，他把改变的节点以及他的父节点进行修改，而其他节点进行共享。他的好处有：
 - 不可变就不会操心方法进行了修改
 - 节省了内存，因为一样的数据是共用的
 - 方便执行撤销/重做，因为每次数据都是不一样
 - 并发安全，数据具有了一致性
 - 拥抱函数式编程

当我们想要给两个组件加上key的话，我们可以使用createFragment来做。

当我们要查看性能的时候，我们可以使用perf来做渲染次数的检测。

动画真的是看不太下去..

### 自动化测试
感觉编写jest测试还是写起来挺难受的，操作步骤都得用测试语言描述出来，得到的结果也是。

有浅渲染和全渲染，浅渲染就是只渲染当前的页面，全渲染就是全部渲染，当你做了直接操作dom的事情的时候，就得全渲染。

## 解读React源码
### 生命周期
生命周期的原形其实是状态机，状态机将复杂的关系简单化，显得自然而直观，用生命周期就可以实现"生命周期-状态-组件"。

无状态组件没有状态，没有生命周期，纯粹是为了渲染而生，如果可以尽量使用无状态组件。

### 事务
将React组件渲染进DOM的过程就是一个事务，所以在一般的生命周期中的setState都是在一次事务中，但是如果用了setTimeout这种函数的话，就脱离于事务之外了，就是立刻执行的了。

### diff算法
其实就是最简单的，如果跨级了直接重绘，同样的就根据shouldComponentUpdate来做，同级的就通过加key，用那种类似快排的方式实现。

diff了之后，react计算出全部差异然后放入差异队列，然后执行patch方法来完成DOM的更新。

## Flux架构模式
Flux中，store对外只提供了get方法，并没有提供set方法

中心化控制让所有的请求和改变都只能通过action，由dispatcher来分配。
