# 6章面向对象的程序设计
重新看一次这一章..

对象就是无序属性的集合，属性包含基本值，对象和函数

## 创建简单对象
我们可以new Object()或者通过对象自变量{}的形式来创建。

每个属性都有一些特性，包括

 - Configurable:能够通过delete删除或者重新定义属性的特性
 - Enumerable:能否通过for in循环返回属性
 - Writable:是否可以修改属性的值
 - Value：属性的数据值

一般这些特性都是true的，想要修改的话，我们只能使用`Object.defineProperty`来进行修改。

有种叫做访问器属性，只能通过defineProperty来进行定义，我们可以定义get和set方法，当然可以不全部指定。

我们还可以通过defineProperties来一次定义多个属性。

### 读取属性的特性
Object.getOwnPropertyDescriptor可以得到想要的属性的特性。

## 创建特定形式的对象
### 工厂模式
最初是工厂模式的，就是简单的一个方法，每次new Object()，然后添加属性，最后返回这个新的对象回去，但是问题来了，我们得不到创建出来的东西的类型，于是有了构造函数的模式

### 构造函数
我们使用构造函数来创建对象，每个对象都能访问到contructor(构造函数)属性，该属性指向构造函数(注意这个constructor并不是实例本身拥有的，而是原型对象会有这个constructor，然后属性查找找到了原型上的contructor而已！！！！！)。

只要创建了一个新函数，就会为该函数创建一个prototype，指向该函数的原型对象。

原型对象会有一个constructor，指向构造函数。

实例对象只拥有一个指针能指向原型对象，一般叫做__proto__，基本都是被隐藏的属性！！

所以

 - 只有原型对象才会有contructor！！其他的实例对象能够访问是因为查找了原型！！
 - 只有函数才有prototype！！！实例对象也拥有指针指向原型对象，就是__proto__！！！

我们一旦在实例上申明了属性覆盖了原型属性，除非我们使用`delete`，才能够访问到原型属性。

Object.getOwnPropertyDescriptor只能得到自己对象上属性的描述符，想得到原型对象上的，只能直接在原型对象上调用这个方法。

想要判断属性是不是原型属性：`!Object.hasOwnProperty(name) && (name in object)`

注意constructr和__proto__规范上也是enumerable为false的，当时并不是所有的浏览器都是这么实现的

Object.keys可以得到for in循环的所有属性，当然不包括enumerable为false的;而Object.getOwnPropertyNames()可以得到所有的实例属性，包括不可枚举的，但是__proto__这种不开放的还是得不到。

### 重写原型
```javascript
//一般情况下我们为原型赋予新的属性，得一次次的敲
```
