# 异步IO，异步编程
## 资源分配
一般的话会使用单线程串行一次执行，还有多线程并行完成，但是单线程串行执行，很明显速度会很慢，性能会很差，而多线程的话，可能会早场死锁以及状态的同步问题。

于是Nodejs采用的单线程，异步IO，用单线程来避免死锁以及状态同步的问题，而异步的IO，则避免了阻塞。而正对无法利用多核CPU的问题，Node提供了子进程的方式来搞笑利用CPU和IO。

## 异步IO与非阻塞IO
异步和非阻塞其实是两回事。

对于操作系统对内核的IO来说，只有阻塞与非阻塞。

阻塞就是就是简单的所有磁盘寻道，读取数据，复制数据之后才返回。

非阻塞IO则是系统发出查询的请求后，请求到达之后不带数据返回，然后通过轮询的方式查看什么时候结束了再来拿取数据。

这种轮询也经历了不断地进步，从不断的发送read；到后来select一次可以检查很多次，因为是数组；到后来的poll，以链表形式突破了长度限制；到后来的epoll，该方案是linux下效率最高的事件唤醒，因为他会休眠到结束，而不会一直轮询。还有kqueue，不过这个只在FressBSD系统下存在。

但是注意在轮询或者休眠的状态下实际上主线程是闲置的，是利用不足的。

Linux下有那种理想的异步IO方式，AIO，但是有缺陷，无法利用系统缓存。

### 现实中的异步IO
其实现实中的异步IO是多线程的的，让部分线程来通过阻塞的或者非阻塞+轮询的形式来拿到数据，然后让一个线程进行计算处理，就实现了异步IO。

最终的结果就是nodejs通过libuv来运行在windows和linux系统上。

注意我们时常的说Node是单线程的，但是其实仅仅只是js执行在单线程中而已，node中，内部完成IO任务的其实都是另有线程池的。

### 非IO的异步API
除了IO之外，还有些异步的API，分别是setTimeout，setInterval，setImmediate和process.nextTick

一般浏览器端我们想要立即异步执行一个函数，就`setTimeout(function(){},0)`就行了，但是定时器需要动用红黑树，创建定时器对象和迭代，浪费性能。

process.nextTick则是比较轻量的，直接将回调函数放入队列。

setImmediate也是类似的，但是这个的优先级比process.nextTick要低，并且如果同时写两个的话，执行了一个之后，`会直接进行下一轮循环`，而不是继续执行。
