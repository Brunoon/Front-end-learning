# node基础
本文摘要了深入浅出nodejs的第一，二章
## Why node？
因为Ryan想找一个事件驱动，并且非阻塞的IO，而且chrome的V8引擎非常强大。

node与chrome很像，node基于V8引擎运行js，通过引擎控制一些中间件来控制网卡，硬盘等等的底层。

chrome也是通过通过V8运行js，通过引擎控制中间件来控制底层的网卡，硬盘。当然chrome还有布局引擎webkit来处理html，也是由布局引擎来通过中间件控制底层的网卡，硬盘。

node的底层api大都被设计为了异步的io，这样在编程模型上可以极大的提高效率。

## 单线程
node保持了javascript在浏览器单线程的特点，所以不会有死锁，不会有线程上下文交换带来的性能上的开销。

但是问题在于：

 - 无法利用多核CPU
 - 一旦挂了，程序退出
 - 计算太多，导致CPU无法继续调用异步IO

node的解决办法是child_process

通过子进程可以应对健壮性和多核CPU的问题，通过将计算分解到各个子进程，然后通过进程间的`事件消息`来传递结果。  

### Node应用场景
毫无疑问，IO密集型node非常强，因为Node面向网络并且擅长执行并行IO，能够有效的组织起更多的硬件资源。

对于CPU密集型的应用，其实v8的深度优化导致计算能力实际上很强，只不过js为单线程应用，长时间计算会阻塞而已，但是通过拆分分解还是不错的。可以使用一些c++的扩展方式，或者通过子进程将一部分的node进程当做常驻服务进行计算。

所以CPU密集型不可怕，合理的调度才是诀窍。

### 模块机制
模块化的出现，改变了js杂乱无章的现状。CommonJS规范是为了Javascript能够在任何地方运行。

Node借鉴Commonjs的Modules规范实现了一套非常易用的模块系统。

### Commonjs的模块规范

 - 模块引用

很简单，require方法，将模块的api引入到上下文中

 - 模块定义

上下文提供了一个exports对象来导出当前模块的方法或者变量。还有一个module对象代表模块自身。exports是module的属性，通过将方法挂载到exports对象上作为属性即可定义导出。

 - 模块标识

 就是传递给require的参数，必须是小驼峰命名的字符串，或者.，..开头的相对或者绝对路径。

 ### Node的模块实现
 引入模块的3个步骤：

  - 路径分析
  - 文件定位
  - 编译执行

Node模块分为核心模块和用户编写的文件模块。

核心模块在编译过程中直接编译为了二进制文件，直接在node运行时被加入内存，所以他没有文件定位和编译执行两步，而且路径分析优先判断。加载最快。

而文件模块则需要完整的3个步骤，所以加载速度比较慢。

注意加载是缓存优先，require方法对相同模块的二次加载都一律采用缓存优先，是`第一优先级`。当然核心模块缓存检查先于文件模块的缓存检查。

#### 路径分析
首先优先核心模块，直接加载，然后是路径形式和文件模块，由于给出了路径，也是最方便的查找过程，其次是自定义的模块，不是核心，也没有路径，他会从当前路径一层层向外查找，直到根目录为止，所以加载速度最慢。

#### 文件定位
分析标识符的时候，可能会不带文件扩展名，这种情况下，node会以js，json，node为次序依次尝试。

    所以小诀窍是，如果是.node和.json文件，最后带上扩展名，会加快速度。

然后如果是目录分析和包的话，会找他的package.json，然后根据man属性的文件名进行定位，找不到则以index.js,index.json,index.node的顺序来找，再找不到，就找下一层，到根目录都找不到，就抛出异常。
