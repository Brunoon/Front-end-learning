---
layout: default
title: {{ site.name }}
---
# Redux文档阅读
Redux是js的一个可预测的状态的管理者。

## 要旨
 - 你的App的所有的状态存在一个单一store的对象树中。
 - 唯一的改变状态树的方法是发出一个action(一个对象描述发生了什么)
 - 通过写纯函数reducer来指定action是如何更改状态树的。

就这么多..

Redux没有一个dispather，并且不支持many stores。

他只拥有一个store和一个单一的reducer方法。

当项目不断演进的过程中，可以分割reducer成为更小的reducer来独立地操作状态树的不同部分。这点很像React app只对外一个根节点，但是它由很多小的部分组成的。

## 动机
随着单页应用的需求变得越来越复杂，我们的代码比起以前而言需要管理更多的状态。这下状态包括服务器的返回，缓存的数据，还有本地的一些数据。UI的状态也变得越来越复杂。

管理这个不断改变的状态是困难的，当我们失去了state的控制之后，我们基本也不懂程序发生了什么了。当一个程序是不透明的和不确定的，很难重现bug或者添加新特性。

问题变得难处理是因为我们把两个人脑很难区分的概念混在了一起，就是异变和异步。

Redux尝试着来让状态突变变得可预测。

## 3个原则
React可以用3个基本原则描述

### 单一来源的真理
你的整个app的状态存在一个单一store的对象树中。

这使得能够创建通用的app，你服务器的状态可以通过序列化传递给客户端，并且没有额外的代码。一个简单的状态树使得调试和反省整个项目变得容易，

### 状态是只读的
唯一的改变状态树的方法是发出一个action(一个对象描述发生了什么)

这点保证了无论是view还是网络的回调都不可能直接修改state。相替代的，他们表示了一个去转换state的意图，因为所有的改变都是按照一个严格顺序一步步执行的，他就没有一个竞态的顺序需要去注意。行动是简单的对象，他们是很容易被统计，存储，以及序列化的。

### 改变是通过纯函数执行的。
通过写纯函数reducer来指定action是如何更改状态树的。

recuder是纯函数，输入原来的状态和action，得到了新的状态。记住我们是返回新的状态对象，而不是在原来的state上进行改变。我们可以从一个单一的reducer开始，然后随着app grow，将它细分成更小的reducer。因为reducer仅仅只是函数，我们可以控制他们执行的顺序，传入外地的数据，甚至在分页这种普遍的任务中使用可重用的reducer。

## 现有技术
Redux是一个混合的遗产。他和一些模式和技术很像，但是也在一些重要的部分与他们是不同的。

### Flux
Flux可以被以为是一个Flux的实现吗？是也不是。Flux的创造者承认了这点。

Redux的灵感来源于Flux的几个重要特性。像Flux一样，Redux让你把model的更新逻辑放到了你的app的一个层去解决。(在Flux中为stores，在Redux中为reducers)。都让你通过一个叫做action的空对象来描述每次突变。

与Flux不同的是，Redux没有一个dispatcher的概念。这是因为他依赖于纯函数，而不是事件发射器。纯函数很容易管理，不需要一个额外的实体来管理他。你可以把它当做一个偏差或者一个实现细节。从(state,action) => state这个方面来看，Redux确实是Flux的架构，但是由于是纯函数，这个就更简单了。

另一个重要的区别是Redux假设你从不突变你的数据。就是说在reducer里面修改这个数据是很不被推荐的，我们应该返回新的数据，类似于Immutable。

我们从技术上是可以写非纯函数来变异数据的，但是我们劝你不要这么做。

### Elm
这是一门语言，被Haskell影响的。他的更新机制updater很像Redux的reducer。他最后会被编译为js。因为他是语言，所以我们可以强制他纯函数。

### Immutable
Immutable是一个js库，实现持久化数据结构。他有比较惯用的js api。

Redux不关心你如何存储一个对象，可以是个简单的对象，可以是个Immutable对象。

### Baobab
另一个为更新简单的JS对象实现了immutable api的库。与Redux一起用的好处不大。因为他的更新是给数据提供了游标修改的，而Redux希望的是只在dispatch一个action来修改数据。

### Rx
这块并不是很能看得懂....
