## 前端基础知识
### 基本数据类型以及typeof的结果
基本数据类型：

null，undefined，string，boolean，number，还有一种复杂的object

typeof的结果：

undefined，number，string，boolean，object，function

### querySelectorAll和getElementByClassName的区别
querySelectorAll是没有性能问题的，因为它不是动态的

getElementByClassName是有性能问题的，他会动态刷新

### 闭包
就是在函数的最后返回一个函数回去，返回的函数拥有访问原函数内部变量以及参数的能力，如果不手动设置为null的话，垃圾回收器是无法回收的

### 阻止冒泡和默认事件
冒泡：e.stopPropagation,IE下位cancelBubble=true，

默认事件，e.preventDefault(),e.returnValue=false,return false(用来取消对象属性注册的处理程序)

### addEventListener的第三个参数
只有在有父元素，并且有同样类型的处理事件时才有用，默认为false，默认为bubble，从内向外，设置为true后，就从外向内触发了。

### 类型检测？？

### 继承？？？

### 变量提升的好处？？？



## 克隆一个对象
```javascript
function clone(obj){
  var newObj;
  if(obj instanceof Array){
    newObj = [];
    for (var i = 0;i < obj.length;i++ ){
      newObj[i] = clone(obj[i]);
    }
  }else if(obj instanceof Object){
    newObj = {};
    for(var k in obj){
      newObj[k] = clone(obj[k]);      
    }
  }else{
    newObj = obj;
  }
  return obj;
}
```

## AMD和CMD规范
AMD依赖前置，所以异步并行加载

CMD按需依赖，所以还是顺序加载

node端是Commonjs

##前端安全
永远不相信前端输入，1个是前端的验证要通过正则啊等等的验证，后端也必须得再校验一遍

### XSS攻击
就是在网页上插入html标签或者javascript代码。

解决：
  - 针对提交的结果后端设置一层filter,对<>进行过滤
  - 东西写到页面上的时候都进行一次encode，放置将html标签显示出来
  - 不在cookie里面存重要的信息

### CSRF(跨站点请求伪造)
 - 进行验证码的验证
 - 传一个token
 - 判断来源referer

两者的区别在于XSS是访问，不需要什么数据，CSRF是一次动作，是需要一些数据包的

## manifest
就是在html元素里定义了这个属性，就可以进行缓存了，当做离线应用进行缓存

## web worker
运营在后台的js，独立于页面，可以不阻塞主线程
